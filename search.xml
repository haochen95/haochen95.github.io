<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2019%2F03%2F04%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文主要的知识点是： java中类的定义 this和static的用法 封装的含义 重载的含义 1. Java的面向对象方法 继承 多态 封装 this的用法 引用隐式参数 调用该类的其他构造器 super的用法 调用超类方法 调用超类的构造器 1.1. 创建类和对象的方法对象和引用的一个关系图： 1.2. 定义class的模板1234567891011class ClassName &#123; field1 // 属性： 描述类的状态 field2 ... constructor1 constructor2 ... method1 // 方法： 描述类的行为 method2&#125; 1.3. 定义实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Main &#123; public static void main(String[] args) throws IOException &#123; // 对象的使用方法 // 对象.变量： staff.name // 对象.函数（）： staff.getname() Employee[] staff = new Employee[3]; staff[0] = new Employee("Zhang", 75000, 1977, 12,15); staff[1] = new Employee("Li", 23000, 1932, 3,5); staff[2] = new Employee("Zhang", 56444, 1964, 6,21); for (Employee e: staff)&#123; e.raiseSalary(5); &#125; for (Employee e: staff)&#123; System.out.println("name=" + e.getName() + ", salary=" + e.getSalary() + ", hireday=" + e.getHireDay()); &#125; &#125;&#125;// 一个类可以有无限多个对象class Employee&#123; // 三个实例域用来存放将要操作的数据 private String name; private double salary; private LocalDate hireDay; // 构造器（与类名同名），总是伴随着new操作符的执行而被调用 // 每个类可以有一个以上的构造器 // 如果类中没有构造器，java会默认有一个构造器用于初始化 // 但是如果类的构造器大于1个的话，需要自己构造默认构造器 // 构造器可以有0,1，...等多个参数 // 构造器没有返回值，即没有void // 构造器总是伴随着new的操作一起调用 public Employee(String n, double s, int year, int month, int day)&#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; // 需要获得或者设置实例域的值，需要提供以下三个内容： // (1).一个私有的数据域 // (2).一个公有的域访问器方法 // (3).一个公有的域更改器方法 public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void setHireDay(LocalDate hireDay) &#123; this.hireDay = hireDay; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; // class方法有两个参数： 显示参数(括号内部的参数) + 隐式参数(引用该方法的对象) // 用this来表示隐式参数，表示使用该方法的对象 public void raiseSalary(double rate)&#123; // 可以直接访问类的属性 double raise = this.salary * rate / 100; this.salary = this.salary + raise; &#125;&#125; 2. Java构造器构造器的注意事项 构造器与类同名 每个类可以有一个以上的构造器 构造器没有返回值 构造类的对象时，构造器会自动运行来初始化类 伴随着new而调用，跟方法不同 1Employee a1 = new Employee("hao"); 2.1. 隐式参数和显式参数方法用于操纵对象以及存取它们的实例域 12a1.raiseSalary(10);// 隐式参数.raiseSalary(显式参数) 关键字this用于代表隐式参数 1234public void raiseSalary(double byPercent)&#123; double raise = this.salary * byPercent / 100; this.salary += raise;&#125; 2.2. 封装的优点在定义一个类的时候，需要提供以下三个内容： 一个私有的数据域； 一个公有的域访问器方法； 一个公有的域更改器方法； 封装的优点如下： 保护数据不给外界破坏 检查输入数据 2.3. final实例域12private final String name;// 一旦建立，不可更改 3. 静态域和静态方法3.1. 静态成员变量静态成员变量的特点： 可以直接通过类名调用 类的对象共用一个静态变量(任何一个对象修改这个变量，所有的静态变量都变了) 理解为类级别的变量 3.2. 静态函数 也可以直接通过类名调用 静态函数中不能使用非静态变量 3.3. 静态代码块在装载类的时候执行,为了静态变量赋予初始值 3.4. main方法main方法也是一个静态方法，其不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象. 实例演示12345678910111213141516171819202122232425262728293031323334353637class Person&#123; // 静态变量 static int i; String name; // 静态函数 static fun()&#123; // System.out.println("我是静态函数" + this.name); 这是错误的 // 静态函数中不能使用非静态变量,如果这是this的话，这个this该如何解释，但是静态函数 // 是直接通过类名调用的，而不是对象调用. System.out.println("我是静态函数"); &#125; // 静态代码块 static&#123; System.out.println("我是静态代码块"); &#125; &#125;class Test&#123; public static void main(String args[])&#123; Person p1 = new Person(); Person p2 = new Person(); Person.i = 10; System.out.println("p1的i值是" + p1.i); System.out.println("p2的i值是" + p2.i); Person.fun(); &#125;&#125;// 结果为// p1的i值是: 10// p2的i值是: 10 4. 函数重载和this关键字4.1. 重载在一个类中允许函数重名的现象 两个或者多个函数在同一个类中 函数名相同 参数列表不同 123456789101112131415class A&#123; void funA()&#123; System.out.println("无参数的funA"); &#125; void funA(int i)&#123; System.out.println("有参数的funA"); &#125;&#125;A a = new A();a.funA(); // 无参数的funAa.funA(10); //有参数的funA 重载在构造函数中的使用,构造函数的特点： 没有返回值的定义 和类名一样 如果类中没有构造函数，编译器会自动添加一个空的构造函数 如果类中已经有了构造函数了，编译器就不会再添加一个无参数的构造函数 作用是为类赋予初始值 构造函数也可以重载 12345678910111213141516class A&#123; String name; int age; A()&#123; &#125; A(String name, int age)&#123; this.name = name; this.age = age; &#125; &#125; 4.2. this的使用 代表调用这个方法(函数)的对象 代表类中的成员变量 调用本类中的另外一个构造函数 12345678910111213141516171819202122232425262728293031323334353637383940class Person&#123; String name; String age; // this 在构造函数的用法 Person()&#123; System.out.println("无参数构造 "); &#125; Person(String name)&#123; this.name = name; &#125; Person(String name, String age)&#123; this(name); this.age = age; &#125; void talk()&#123; // this在方法中的用法 System.out.println("My name is " + this.name); &#125;&#125;class Test&#123; public static void main(String args[])&#123; Person p1 = new Person(); p1.name = "zhangsan"; Person p2 = new Person(); p2.name = "lisi"; p1.talk(); p2.talk(); &#125;&#125;// 结果为 // my name is zhangsan// my name is lisi]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法知识点]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发路线图]]></title>
    <url>%2F2019%2F03%2F03%2FAndroid%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密测试]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[密码为“你好”的拼音 Incorrect Password! No content to display! U2FsdGVkX181NQhOlNIz53Nmet1zMN53tySuXTFpc8Jd/mw0gnx4mzfBQRvMPJfmc6Ok4QHfUvmL0kLIhuJWyZhdDG1hrGGWqidXUepNLrqhUOLKD5hU4DE16wWMsg4SF3AjK7SsM4lW5Bnx+26DKxMSVMCbQlZRd1uJIkZf2TvIohaoml9sYikJ62QzzqzXDknwsaKfUATjA4ypZ4sX/qwjloXbgRO9/KdUPwcB+eqGysatawGYWmt2O0b9gXtQ7WGpSY4j79+5MMiMa5AP2ggzapHapd+qsw9y3FeCmmS2Im9E7OFP+vs1UL0wVN8wCbXqlXmnJZwvNl9Zv4tS5w==]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式语法以及re模块的使用]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8Are%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.正则表达式简介正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言，你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE以各种方式来修改或分割字符串。 2.正则表达式的语法简介 3.re模块的介绍3.1.re模块的核心函数和方法通过 pattern object 的方法（除 findall 外）进行匹配得到的返回结果都是 match object。每一个 match object 都包含了匹配到的相关信息，比如，起始位置、匹配到的子串。那么，我们如何从 match object 中提取这些信息呢？ 函数 描述 re.compile(pattern,flags=0) 将一个字符串通过指定的匹配模式flag编译成 pattern object，用于匹配或搜索 pattern.match(string[, pos[, endpos]]) 匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None pattern.search(string[, pos[, endpos]]) 扫描整个字符串，并返回它找到的第一个匹配（Match object） pattern.findall(string[, pos[, endpos]]) 找到所有匹配的子串，并返回一个 list pattern.finditer(string[, pos[, endpos]]) 找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器 pattern.split(rules,string,max=0) 根据正则表达式的rules，将字符串string分割成列表并返回 pattern.sub(rules,repl,string,count=0) 根据正则表达式rules匹配的结果将它替换为repl的形式，除非定义count，否则替换所有 pattern.purge() 清除所有的正则表达式 match.group([group1, …]) 返回 match object 中的字符串。 每一个 ( ) 都是一个分组，分组编号从1开始 match.groups(default=none) 返回由所有分组匹配到的字符串组成的 tuple。 match.groupdict(default=None) 返回一个包含所有匹配的命名子组的字典，子组名称为键 match.start([group]) 没有参数时，返回匹配到的字符串的起始位置,指定参数（整数）时，返回该分组匹配到的字符串的起始位置。。 match.end([group]) 没有参数时，返回匹配到的字符串的结束位置。 指定参数（整数）时，返回该分组匹配到的字符串的结束位置。 match.span 返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)。 re.I 不区分大小写的匹配 re.L 使用预定字符类\w\W\b\B\s\Sq取决于当前区域设定 re.M 多行模式 re.S 使得句号匹配除换行符外的所有单个字符 \ 转义符号 4. Python中的范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import re# regex.match(string[, pos[, endpos]])# 匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None。print("\n-------match的用法--------\n")p1 = re.compile(r'ar&#123;1&#125;')print("当不指定位置时,match只从开头匹配:匹配成功 ",p1.match("army"))print("当不指定位置时,match只从开头匹配:匹配失败 ",p1.match("akarmy"))print("match从指定位置的开头匹配:匹配成功 ",p1.match("akarmy",2))# regex.search(string[, pos[, endpos]])# 扫描整个字符串，并返回它找到的第一个匹配（Match object）。print("\n-------search的用法--------\n")print("search用法：匹配成功 ",p1.search("akarmy"))# regex.findall(string[, pos[, endpos]])# 找到所有匹配的子串，并返回一个 list 。print("\n-------findall的用法--------\n")p2 = re.compile(r"\d+")print("从字符串中找到所有数字",p2.findall("abc1def2rst3xyz"))# regex.finditer(string[, pos[, endpos]])# 找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器 。print("\n-------finditer的用法--------\n")for i in p2.findall("abc1def6rst25xyz"): print(i)# re.split(pattern, string, maxsplit=0, flags=0) 模块级函数print("\n-------split的用法--------\n")p2_1 = re.compile(r"[A-Z]+")print("根据大写字母分割字符串",p2_1.split("abcDefgHijkLmnoPqrs"))# re.sub(pattern, repl, string, count=0, flags=0)：# 替换函数print("\n-------sub的用法--------\n")def fun(m): return m.group().upper()pattern = re.compile(r"like", re.I)s1 = pattern.sub(r"love", "I like you, do you like me?")s2 = pattern.sub(fun, "I like you, do you like me?")print("love替换为like",s1)print("替换函数的使用",s2)# match.group([group1, ...])# 返回 match object 中的字符串。每一个 ( ) 都是一个分组，分组编号从1开始print("\n-------match.group的用法--------\n")p3 = re.compile(r"(\w+) (\w+)")m = p3.match("Kobe Bryant, Lakers")print("match object", m)print("完整匹配",m.group())print("match first group", m.group(1))print("match second group", m.group(2))# match.groups()# 返回由所有分组匹配到的字符串组成的 tupleprint("\n-------match.group的用法--------\n")print("match all the groups",m.groups())# match.start([group])# 没有参数时，返回匹配到的字符串的起始位置。指定参数（整数）时，返回该分组匹配到的字符串的起始位置。print("\n-------match.start的用法--------\n")print("返回第一个匹配开始的index值",m.start())print("返回第二组匹配开始的index值",m.start(2))# match.span([group])# 返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)print("\n-------match.span的用法--------\n")print("返回第一个匹配的index范围值",m.span())print("返回第二个匹配的index范围值",m.span(2))# flags匹配模式的使用a = re.compile(r"like",re.I)print("忽略大小写的匹配",a.findall("I like you, do you LIKE me,or LiKes?")) 其输出结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-------match的用法--------当不指定位置时,match只从开头匹配:匹配成功 &lt;re.Match object; span=(0, 2), match=&apos;ar&apos;&gt;当不指定位置时,match只从开头匹配:匹配失败 Nonematch从指定位置的开头匹配:匹配成功 &lt;re.Match object; span=(2, 4), match=&apos;ar&apos;&gt;-------search的用法--------search用法：匹配成功 &lt;re.Match object; span=(2, 4), match=&apos;ar&apos;&gt;-------findall的用法--------从字符串中找到所有数字 [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]-------finditer的用法--------1625-------split的用法--------根据大写字母分割字符串 [&apos;abc&apos;, &apos;efg&apos;, &apos;ijk&apos;, &apos;mno&apos;, &apos;qrs&apos;]-------sub的用法--------love替换为like I love you, do you love me?替换函数的使用 I LIKE you, do you LIKE me?-------match.group的用法--------match object &lt;re.Match object; span=(0, 11), match=&apos;Kobe Bryant&apos;&gt;完整匹配 Kobe Bryantmatch first group Kobematch second group Bryant-------match.group的用法--------match all the groups (&apos;Kobe&apos;, &apos;Bryant&apos;)-------match.start的用法--------返回第一个匹配开始的index值 0返回第二组匹配开始的index值 5-------match.span的用法--------返回第一个匹配的index范围值 (0, 11)返回第二个匹配的index范围值 (5, 11)忽略大小写的匹配 [&apos;like&apos;, &apos;LIKE&apos;, &apos;LiKe&apos;] 参考资料如下： https://blog.csdn.net/lisonglisonglisong/article/details/39697137 https://www.cnblogs.com/haochen273/p/10256418.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8Are%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8]]></content>
      <categories>
        <category>Python核心编程</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP套接字介绍及Socket模块的使用]]></title>
    <url>%2F2019%2F03%2F02%2FTCP%E5%92%8CUDP%E5%A5%97%E6%8E%A5%E5%AD%97%E4%BB%8B%E7%BB%8D%E5%8F%8ASocket%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.客户端/服务端架构 服务端的作用: 等待客户端的请求，并相应他们提供服务，然后等待更多请求 客户端的作用： 发送请给给服务端以获取相关信息 注意： 客户端和服务器交互之前，需要进行一些必要的设置： 设置通信端点(比如，你要上网，必须要网线插口才可以) 客户端需要做的就是创建一个它的单一通信端点，然后建立一个到服务器的连接，然后，客户端就可以发送请求，一旦请求诶服务器处理，且客户端收到了请求的结果，此次通信就结束了 2. 套接字3. Python中的网络编程socket3.1. socket()模块函数创建套接字的语法如下： 1socket.socket(socket_family, socket_type, protocol=0) socket_family： 是AF_UNIX(基于文件的套接字)和AF_INET(基于网络的套接字) socket_type: SOCK_STREAM(面向连接的套接字，也称为TCP/TP套接字) + SOCK_DGRAM(无连接套接字，也称为UDP/TP套接字) protocol：一般为0，不用设置这个 123from socket import *tcpSock = socket(socket.AF_INET,socket.SOCK_STREAM) # 创建TCP/TP套接字udpSock = socket(socket.AF_INET,socket.SOCK_DGRAM) # 创建UDP/IP套接字 3.2. 套接字对象的方法 名称 说明 类别 s.bind() 将地址(主机名-端口号对)绑定到套接字上 服务器套接字方法 s.listen() 设置并启动TCP监听器 s.accept() 被动接受TCP客户端连接，一直等待直到连接到达(阻塞) s.connect() 主动发起TCP服务器连接 客户端套接字方法 s.connect_ex() connect的扩展，会以错误码的形式返回问题 s.recv() 接收TCP信息 普通的套接字方法 s.recv_into() 接收TCP信息到指定发缓存区 s.send() 发送TCP信息 s.sendall() 完整地发送TCP信息 s.recvfrom() 接收UDP信息 s.recvfrom_into() 接收UDP信息到指定的缓冲区 s.sendto() 发送UDP信息 s.getpeername() 连接到套接字TCP的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式 s.setblocking() 设置套接字的阻塞或者非阻塞模式 面向阻塞的套接字方法 s.settimeout() 设置阻塞套接字的操作的超时时间 s.gettimeout() 获取阻塞套接字操作的超时时间 s.fileno() 套接字的文件描述符 面向文件的套接字方法 s.makefile() 创建与套接字关联的文件对象 s.family 套接字家族 数据类型 s.type 套接字类型 s.proto 套接字协议 3.3. 创建TCP服务器这里我给出了创建TCP服务器的一般流程 123456789ss = socket() # 创建服务器套接字ss.bind() # 套接字与地址绑定ss.listen() # 监听连接inf_loop: # 服务器无线循环中 cs = ss.accept() # 接收客户端连接 comm_loop: # 通信循环 cs.recv/cs.send() # 对话：接收或者发送 cs.close() # 关闭客户端套接字ss.close() # 关闭服务端套接字(可选) 所有套接字都需要通过socket.socket()来创建来占用一个端口bind()并等待客户端的请求 因为TCP是面向连接的通信，在执行请求前，需要设置一些监听设备listen()，一旦完成，就开始服务器的无线循环inf_loop 一旦服务器接收accpet()了一个连接，就会返回一个独立的客户端套接字cs，用它来与即将到来的信息进行交换(类似于主线员将这个客户切换给一个专用的客服代表，这样主线员就可以空出来继续接收连接) 通信开始，执行相关操作cs.recv或者cs.send() 完成通信，关闭客户端套接字(切断客服代表的电话)cs.close() 123456789101112131415161718192021222324252627282930from socket import *from time import ctimeimport threadingHOST = ''PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)tcpSerSock = socket(AF_INET,SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print("等待连接中....") tcpCliSock, addr = tcpSerSock.accept() print("获取了一个的连接: ",addr) while True: data = tcpCliSock.recv(BUFSIZ) SendText = 'Thanks for your connections---' + data.decode() print(type(data)) if not data: break tcpCliSock.send(SendText.encode()) tcpCliSock.close()tcpSerSock.close() 3.4. 创建TCP客户端这里我们给出创建TCP客户端的模板 12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话发送，接收cs.close() # 关闭客户端套接字 标准的TCP实例如下 123456789101112131415161718192021from socket import *HOST = 'localhost'PORT = 1565BUFSIZ = 1024ADDR = (HOST,PORT)tcpCliSock = socket(AF_INET,SOCK_STREAM)tcpCliSock.bind(ADDR)while True: data = input('&gt;') if not data: break tcpCliSock.send(data.encode()) data = tcpCliSock.recv(BUFSIZ) if not data: # 服务器端终止且对recv()方法的调用失败 break print(data.decode('utf-8'))tcpCliSock.close() 3.5. 运行TCP服务-客户端 首先运行TCP服务端 然后运行TCP客户端，并且输入Python 3.6. 创建UDP服务器UDP服务器不像TCP服务器那么多设置，因为UDP服务器不是面向连接的，除了等待传入的连接外，几乎不需要做其他任何工作 1234ss = socket()ss.bind()inf_loop: cs = css.recvfrom()/ss.sendto() 特点：服务器只接受小象，并可能回复数据 1234567891011121314151617181920from socket import *HOST = ''PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)udpServer = socket(AF_INET,SOCK_DGRAM)udpServer.bind(ADDR)while True: print("等待连接....") data,addr = udpServer.recvfrom(BUFSIZ) print("获取了一个的连接: ", addr) SendText = 'Thanks for your connections---' + data.decode() udpServer.sendto(SendText.encode(),addr)udpServer.close() 3.7. 创建UDP客户端12345678910111213141516171819202122from socket import *HOST = 'localhost'PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)udpCliSock = socket(AF_INET,SOCK_DGRAM)while True: into = input("&gt;") if not into: break udpCliSock.sendto(into.encode(),ADDR) data,ADDR = udpCliSock.recvfrom(BUFSIZ) if not data: break print(data.decode('utf-8'))udpCliSock.close() 运行服务端，以及客户端 参考文献 https://www.cnblogs.com/liu-yao/p/5283379.html]]></content>
      <categories>
        <category>Python网络编程</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中SocketServer的使用]]></title>
    <url>%2F2019%2F03%2F02%2FPython%E4%B8%ADSocketServer%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SocketServer模块介绍 SockerServer是创建网络客户端和服务器所必须的代码，这个模块有为你创建的各种各样的类 类 描述 BaseServer 包含服务器的核心功能 TCPServer/UDPServer 基于网络的TCP/UDP服务器 UnixStreamServer/UnixDatagramServer 基于文件的基础同步TCP/UDP服务器 ForkingMixIn/ThreadingMixIn 核心派出或者线程功能 ForkingTCPServer/ForkingUDPServer ForkingMixIn和TCPServer/UDPServer的组合 ThreadingTCPServer/ThreadingUDPserver ThreadingMixIn和TCPServer/UDPServer的组合 BaseRequestHandler 包含处理服务请求的核心功能 StreamRequestHandler/DatagramRequestHandler 实现TCP/UDP服务器的服务处理器 2. 创建SocketServer TCP服务器12345678910111213141516171819202122from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)HOST = ''PORT = 21567ADDR = (HOST,PORT)class MyRequestHandler(SRH): # 重写SRH中的handle方法 # 当接收一个来自客户端的信息时，他就会调用handle()方法 def handle(self): print("获取了一个的连接: ", self.client_address) # SRH将输入和输出套接字看成类似文件的对象，我们可以通过readline()来获取客户端信息，并通过write()将字符串发送给客户端 SendText = 'Thanks for your connections---' + self.rfile.readline() self.wfile.write(SendText)tcpServ = TCP(ADDR,MyRequestHandler)print("等待连接.....")# 无线循环下去tcpServ.serve_forever() 3. 创建SocketServer TCP客户端12345678910111213141516171819202122from socket import *HOST = 'localhost'PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)while True: # socketserver的默认行为：接收连接、获取请求、关闭连接 # 我们不能再整个应用执行过程中一直保持连接，每次向服务器发送消息时，都需要创建一个新的套接字 tcpClient = socket(AF_INET, SOCK_STREAM) tcpClient.connect(ADDR) into = input("&gt;") if not into: break tcpClient.send(into.encode()) data = tcpClient.recv(BUFSIZ) if not data: break print(data.strip()) tcpClient.close()]]></content>
      <categories>
        <category>Python网络编程</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts的API配置内容]]></title>
    <url>%2F2019%2F03%2F02%2Fpyecharts%E7%9A%84API%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[基本用法安装pyecharts 1pip install pyecharts 图表配置图形初始化选项 接收参数 默认值 说明 title(str) “” 主标题 subtitle(str) “” 副标题 width(int) 800px 画布宽度 height(int) 400px 画布高度 title_pos(str/int) left 标题距离左侧距离 title_top(str/int) top 标题距离顶部距离 title_color(str) #000 主标题颜色 subtitle_color(str) #aaa 副标题颜色 title_text_size(int) 18 主标题字体大小 subtitle_text_size (int) 12 副标题字体大小 background_color(str) ‘#fff’ 画布背景颜色 page_title (str) ‘Echarts’ 指定生成的 html 文件中 &lt;title&gt; 标签的值 renderer(str) ‘canvas’ 指定使用渲染方式 extra_html_text_label(list) is_animation(bool) True 是否开启动画 通用配置项：add()中设置xyAxis：轴相关设置 设置选项 格式 说明 is_convert bool 是否交换 x 轴与 y 轴 is_xaxislabel_align bool x 轴刻度线和标签是否对齐 is_xaxis_inverse bool 是否反向 x 坐标轴。 is_xaxis_boundarygap bool x 轴两边留白策略，适用于类目轴。 is_xaxis_show bool 是否显示 x 轴 is_splitline_show bool 是否显示 y 轴网格线。 x_axis list x 轴数据项 xaxis_interval int x 轴刻度标签的显示间隔，在类目轴中有效。 xaxis_margin int x 轴刻度标签与轴线之间的距离 xaxis_name string x 轴名称 xaxis_name_size int x 轴名称体大小 xaxis_name_gap in x 轴名称与轴线之间的距离。 xaxis_name_pos str x 轴名称位置，有’start’，’middle’，’end’可选 xaxis_min int/float x 坐标轴刻度最小值，默认为自适应。 xaxis_max int/float x 坐标轴刻度最大值，默认为自适应。 xaxis_pos str x 坐标轴位置，有’top’,’bottom’可选 xaxis_label_textsize int x 坐标轴标签字体大小。 xaxis_label_textcolor str x 坐标轴标签字体颜色。 xaxis_type str x 坐标轴类型（value,category,log） xaxis_rotate int x 轴刻度标签旋转的角度 xaxis_formatter str x 轴标签格式器（回调函数） xaxis_line_color str x 坐标轴线线的颜色。 xaxis_line_width int x 坐标轴线线的宽度。 datazoom：缩放设置一般不用，详情请看http://pyecharts.org/#/zh-cn/charts_configure legend:图例组件 设置选项 格式 说明 is_legend_show bool 是否显示顶端图例 legend_orient str 图例列表的布局朝向 legend_pos str 图例组件离容器左侧的距离’left’, ‘center’, ‘right’ legend_top str 图例组件离容器上侧的距离 legend_selectedmode str/bool 图例选择的模式，控制是否可以通过点击图例改变系列的显示状态 legend_text_size int 图例名称字体大小 legend_text_color str 图例名称字体颜色 label:文本标签 设置选项 格式 说明 is_label_show 是否正常显示标签 is_label_emphasis 是否高亮显示标签 label_pos 标签的位置’top’, ‘left’, ‘right’, ‘bottom’, ‘inside’,’outside’ label_emphasis_pos 高亮标签的位置’top’, ‘left’, ‘right’, ‘bottom’, ‘inside’,’outside’ label_text_color 标签字体颜色 label_emphasis_textcolor 高亮标签字体颜色 label_text_size 标签字体大小 label_emphasis_textsize 高亮标签字体大小 is_random 是否随机排列颜色列表 label_color 自定义标签颜色 label_formatter toolbox 设置选项 格式 说明 is_toolbox_show bool 是否显示右侧实用工具箱 is_more_utils bool 指定是否提供更多的实用工具按钮]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础语法]]></title>
    <url>%2F2019%2F03%2F02%2FMySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本MySQL语法从CMD中调用mysql运行以下代码mysql -u root -p连接服务器并且输入密码 创建数据库 语法 用法说明 create database 数据库名字 charset=utf8; 创建数据库 drop database 数据库名字; 删除数据库 use 数据库名字; 使用这个数据库 show databases; 查看当前的所有数据库 select database(); 查看当前正在用的是哪个数据库 创建数据库下面的表 语法 用法说明 show tables; 查看所有的表 create table 表名(列和其类型); 创建表 desc 表名; 查看表的结构 `alter table 表名 add change drop 列名 类型；` 修改表(增加，修改，删除列) drop table 表名; 删除表 rename table 原表名 to 新表名; 更改表的名字 show create table 表名; 查看表的创建语句 表格中的数据操作 语法 用法说明 select * from 表名; 查询数据 insert into 表名 values(…); 添加数据（顺序要与表格一致）:全列插入 insert into 表名(列1，..，) values(…); 添加数据（顺序要与表格一致）:指定列插入 insert into 表名 values(),()…; 添加数据：一次性插入多条数据 update 表名 set 列1=值1,… where 条件; 修改数据 delete from 表名 where 条件; 删除数据 例子演示123456789101112131415161718create table students( id int auto_increment primary key not null, name varchar(10) not null, gender bit default 1, birthday datetime ) alter table students add isDelete bit default 0;desc students; show create table students; insert into students values(0, &apos;hao&apos;,1,&apos;1991-1-1&apos;,0);insert into students(name) values(&apos;a1&apos;),(&apos;a2&apos;),(&apos;a3&apos;);update students set birthday=&apos;1990-2-5&apos; where id=2;select * from students; 123456789101112131415161718192021222324252627+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || gender | bit(1) | YES | | b&apos;1&apos; | || birthday | datetime | YES | | NULL | || isDelete | bit(1) | YES | | b&apos;0&apos; | |+----------+-------------+------+-----+---------+----------------+ | students | CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) NOT NULL, `gender` bit(1) DEFAULT b&apos;1&apos;, `birthday` datetime DEFAULT NULL, `isDelete` bit(1) DEFAULT b&apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 | +----+------+--------+---------------------+----------+| id | name | gender | birthday | isDelete |+----+------+--------+---------------------+----------+| 1 | hao |  | 1991-01-01 00:00:00 | || 2 | hao |  | 1991-01-01 00:00:00 | || 3 | kjkj |  | NULL | | MySQL查询语句查询的基本语法是 1234select * from students; # 全部查询select id,name from students; # 根据条件选择select distinct gender from students; # 消除重复行select distinct id, gender from students; # 消除重复行(id, gender全部相同时才会消除) 条件where对行数据进行筛选，满足要求的出现在结果集中，不满足的直接舍弃不要 先查看condition，在执行select 1select * from 表名 wehre conditions; condition的写法 比较运算符： =, &gt;, &lt;, &gt;=,&lt;=, != 1select * from students where id&gt;3; 逻辑运算符： and, or, not 1select * from students where id&gt;3 and gender=0; 模糊查询： 关键字： like %表示任意多个字符 _表示任意一个字符例子：查询姓黄的学生 1select * from students where name like &apos;黄%&apos;; 例子：查询黄（两个字）的学生 1select * from students where name like &apos;黄_&apos;; 例子：查询名字中间有财的的学生 1select * from students where name like &apos;%财%&apos;; 范围查询 12select * from students where id in (1,3,8);select * from students where id between 3 and 8; 空判断 12select * from students where birthday is null;select * from students where birthday is not null;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的基本语法及在python中的实现]]></title>
    <url>%2F2019%2F03%2F02%2FMySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%9C%A8python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文的主要目的是： 通过一个例子全方位了解mysql的基础以及深度使用语法 建立一个students表格,查询等操作和scores,subject关联，聚合操作 python和mysql的交互操作 和students表格交互 更高效的python-mysql语法 代码封装用户登录系统 使用到的包为： mysql, pymysql, hashlib 1. MySQL语法1.1. 创建students数据库1234567891011121314151617181920212223242526272829303132333435mysql -u root -p # 查看有多少数据库show databases;# 创建数据库create database practice charset='utf8'; # 删除数据库# drop database practice# 使用数据库use practice;# 创建tablecreate table students( id int primary key auto_increment not null, name varchar(10), birthday datetime, gender bit default 1);# 查看数据库下所有的tableshow tables; # 修改tablealter table students add isDelete bit default 0;# 删除表格# drop table practice# 查看table的结构desc table;# 查看创建table的语句show create table students; 12345678910111213141516171819202122232425262728293031323334353637+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || python3 || sakila || sys || world |+--------------------++----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | YES | | NULL | || birthday | datetime | YES | | NULL | || gender | bit(1) | YES | | b&apos;1&apos; | || isDelete | bit(1) | YES | | b&apos;0&apos; | |+----------+-------------+------+-----+---------+----------------++--------------------+| Tables_in_practice |+--------------------+| students |+--------------------+1 row in set (0.00 sec) students | CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) DEFAULT NULL, `birthday` datetime DEFAULT NULL, `gender` bit(1) DEFAULT b&apos;1&apos;, `isDelete` bit(1) DEFAULT b&apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 1.2. MySQL数据操作增加数据123456789# 方法 1： 直接插入insert into students values(1,'hao','1995-10-10',1,0);insert into students values(2,'li','2001-9-8',1,0);insert into students values(3,'wang','2015-2-15',0,0);# 方法2： 选择列 + 多数据同时插入insert into students(name) values('meng'),('bei');select * from students; 123456789+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 1 | hao | 1995-10-10 00:00:00 |  | || 2 | li | 2001-09-08 00:00:00 |  | || 3 | wang | 2015-02-15 00:00:00 | | || 4 | meng | NULL |  | || 5 | bei | NULL |  | |+----+------+---------------------+--------+----------+ 删除数据1234567891011delete from students where name = &quot;meng&quot;;+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 1 | hao | 1995-10-10 00:00:00 |  | || 2 | li | 2001-09-08 00:00:00 |  | || 3 | wang | 2015-02-15 00:00:00 | | || 5 | bei | NULL |  | |+----+------+---------------------+--------+----------+ 查询数据这部分单独拿出来讲 1.3. MySQL查询操作1.条件查询where1select * from 表名 wehre conditions; condition的写法 比较运算符： =, &gt;, &lt;, &gt;=,&lt;=, != 1select * from students where id&gt;3; 逻辑运算符： and, or, not 1select * from students where id&gt;3 and gender=0; 模糊查询： 关键字： like %表示任意多个字符 _表示任意一个字符例子：查询姓黄的学生 1select * from students where name like &apos;黄%&apos;; 例子：查询黄（两个字）的学生 1select * from students where name like &apos;黄_&apos;; 例子：查询名字中间有财的的学生 1select * from students where name like &apos;%财%&apos;; 范围查询 12select * from students where id in (1,3,8);select * from students where id between 3 and 8; 空判断 12select * from students where birthday is null;select * from students where birthday is not null; 2. 聚合为了快速得到统计数据，提供了5个聚合函数 12345select count(*) from students; # 统计有多少行select max(id) from students where gender=0; # 求最大值select min(id) from students where gender=0; # 求最大值select sum(id) from students where gender=0; # 求和select avg(id) from students where gender=0; # 求最大值 3.分组groupby 按照字段分组，表示此字段相同的数据会被放到一个组中（为了更好的统计数据） 分组后，只能查询相同的数据列，有差异的数据列无法显示在结果列中 语法是 1select 列1，列2，聚合... from 表名 group by 列1， 列2，列3... 12345678select gender ,count(*) from stundets group by gender; # 查询男女生总数 +--------+----------+| gender | count(*) |+--------+----------+|  | 3 || | 1 |+--------+----------+ 分组后筛选1select 列1，列2，聚合... from 表名 group by 列1， 列2，列3... having 列1...聚合.... 分组病筛选例子 12select gender ,count(*) from stundets group by gender having gender=0;select gender ,count(*) as rs from stundets group by gender having rs&gt;2; # rs为一个count()的标记名 where是对from后面指定的表进行数据筛选，属于原始数据的筛选 having是对group by的结果进行筛选 4.排序 asec升序排， desc降序排 1select * from 表名 order by 列1 asc |desc, 列2 asc |desc,... 排序例子1select * from students where isdelete=0 and gender=1 order by id desc; 1234567+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 5 | bei | NULL |  | || 2 | li | 2001-09-08 00:00:00 |  | || 1 | hao | 1995-10-10 00:00:00 |  | |+----+------+---------------------+--------+----------+ 5. 分页 limit 当数据量过大时，分页查看数据 1select * from 表名 limit start, count # 从start开始，获取count条数据 已知：每个显示m条数据，当前是第n页(n=1,…) 1select * from students where isdelete=0 limit (n-1)*m, m 6. 总结完整的查询语句 12345select * from tablewhere ...group by ... having....orderby ....limit start, count 1.2. MySQL关系操作1. 关系分析分析 分析： 一个成绩对应有多个科目，在成绩中创建外键引用 创建表的语句 12345create table scores( -&gt; id int primary key auto_increment not null, -&gt; stuid int, -&gt; subid int, -&gt; score decimal(4,1)); 2. 使用外键保证关系数据的有效性 必须是学生表中id列存在的数据，可以通过外键约束进行数据的有效性验证 123456789101112# 添加外键约束 alter table scores add constraint stu_sco foreign key(stuid) references student (id);# 或者直接在创建的时候添加约束 create table scores( id int primary key auto_increment not null, stuid int, subid int, score decimal(4,1), foreign key(stuid) references students (id), foreign key(subid) references subjects (id)); 只有stuid在students的id中才有效，同理subid 3. 连接join当我们查看scores表的时候呈现的结果是这样的 123456789mysql&gt; select * from scores;+----+-------+-------+-------+| id | stuid | subid | score |+----+-------+-------+-------+| 1 | 1 | 1 | 100.0 || 2 | 2 | 2 | 98.0 || 3 | 2 | 1 | 96.0 || 4 | 1 | 2 | 86.0 |+----+-------+-------+-------+ 但是这个表一点都不直观，我哪里知道stuid的1和2代表的谁啊？如果能够显示出人名就好啦，目标效果为 12 张山 数学 100students.name subjects.title scores.score 方法 1234select students.name,subjects.title,scores.score from scores inner join students on stuid = students.idinner join subjects on scores.subid = subjects.id; 1234567+------+---------+-------+| name | title | score |+------+---------+-------+| hao | math | 100.0 || hao | math | 96.0 || hao | english | 98.0 || hao | english | 86.0 | 结果来源于多张表的时候，使用连接查询 连接查询的种类 inner join： 内连接，要求连接的表都匹配的才会出现 left join： 左连接， 对应数据都有 + 左边表信息也会显示出现，内容为NULL right join： 右连接，上同 4. 自关联设计一个省的表结构provinces id ptitle设计一个市信息的表结构citys id ctitle proid（城市所属的省-id） 问题： 每次新建一张表的开销大，而且储存的内容很少—： 有没有可能将这两个表统一成一张表呢？ 答案：自关联： 表中的某一列，关联了这个表的另外一列 123456create table areas( id int primary key, atitle varchar(20), pid int, foreign key(pid) references areas(id) ); 导入外部sql文件 1source area.sql; 查询一共有多少省 1select count(*) from areas where pid is null 查询省的名称为“山西省”的所有城市 123select city.* from areas as cityinner join areas as province on city.pid=province.aidwhere province.atitle=&quot;山西省&quot;; 查询市的名称为“广东市”的所有区县 123select dis.* from aras as disinner join areas as city on city.aid = dis.prdwhere city.atitle = &quot;广州市&quot;; 5. 视图 对于复杂的查询，多次使用时，维护很麻烦 解决：定义视图——来代表复杂的查询 视图本身是对查询的一个封装 123456789# 创建viewcreate view myview asselect * from scoresinner join students on scores.stuid = students.idinner join subjects.on scores.subid = subjects.id;# 使用视图select * from myview; 6. 事务:git版本回退功能 当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，希望整个操作都退回 使用事务可以完成退回的功能，保证业务逻辑的正确性 事务的四大特征（ACID）: 原子性(Atomicity): 事务的全部操作在数据库中时不可分割的，要么全部完成，要么不执行 一致性(Consisitency)： 几个并行执行的事务，其执行结果必须与按照某一顺序串行执行的结果一致 隔离线(Isolation)： 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的 持久性(Durability)： 对于任意已经提交的事务，系统必须保证该事务对数据库的改变不被丢弃 要求：表的类型必须是innodb或者bdb类型才能使用事务 使用情况：当数据被更改时，insert, alter等 123456789# 查看表的创建语句show create table students;# 修改表的类型alter table 表名 engine=innodb;# 事务语句开启begin；提交commit；回滚rollback； 例子： 12345begin; # 开启数据update students set name = &apos;option&apos; where id=1; # 修改数据commit; # 提交修改rollback; # 修改被放弃了 2. Python和MySQL的交互安装mysql for python 1pip install PyMySQL 2.1 基本用法1. Connector对象 用于建立与数据库的连接 创建对象：调用connect()方法 1conn = connect(host主机, port端口, db数据库名称, user用户, password密码, charset) 对象的方法有 close()关闭 commit()提交事务 rollback()撤销操作 cursor()返回Cursor对象，用于执行sql语句并且获得结果 2. Cursor对象 执行sql语句 创建对象： 调用Connection对象的cursor()方法 1curxor1 = conn.cursor() 对象方法 close()： 关闭 execute(operation [, paramters])： 执行语句，返回受影响的行数 fetchone()： 执行查询语句时，获取查询结果集的第一行数据，返回一个元组 next()： 执行查询语句时，获取当前行的下一行 fetchall()： 执行查询时，获取结果期的所有行，一行构成一个元组 scroll(value, [mode]) 将行指针移动到某个位置 mode：移动的方式 mode：默认为relative，表示基于当前行移动到value，value为正则向下移动 mode的值Wieabsolute，表示基于第一条数据的位置(0) 对象的属性 rowcount：只读属性，表示最近一次exectute()返回的行数 connection: 获取当前的连接对象 2.2 增改删查12345678910111213141516171819202122232425262728293031from pymysql import *try: # 通过connect连接mysql数据库 conn = connect(host='localhost',port=3306,database='python3', user='root',password='720678',charset='utf8') # 获得Cursor对象 cursor1 = conn.cursor() # 增加数据 cursor1.execute('insert into students(name) values("飞机")') # 更新数据 cursor1.execute('update students set name="大炮" where name = "a1"') # 删除数据 cursor1.execute('delete from students where id = 10') # 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交 conn.commit() # 关闭Cursor对象 cursor1.close() # 关闭Connection对象 conn.close() print("MySQL operation works. Congrad...")except Exception: print("Wrong!!!!") 下面来看看怎么查看数据 1234567891011121314151617181920212223242526272829try: conn = connect(host='localhost',port=3306,database='python3', user='root',password='720678',charset='utf8') cursor1 = conn.cursor() # 查询数据 count = cursor1.execute('select id, name from students where id&gt;=5') # 打印受影响的行数 print("查询到%d条数据:" % count) for i in range(count): # 获取查询的结果 result = cursor1.fetchone() # 打印查询的结果 print(result) conn.commit() cursor1.close() conn.close() print("MySQL operation works. Congrad...")except Exception: print("Wrong!!!!") 2.3. 参数化 执行数据库中的内置函数，通过调用参数来查询 1234sname = input("请输入学生姓名：")params = [sname]count = cursor1.execute('insert into students(name) values(%s)', params) 2.4. 封装上述代码一看 就有重复性，我们可以将它封装到一个类中，实际应用中我们只关注他的sql语句的书写 (4.4) 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445import pymysqlclass MySQLHelper(): def __init__(self,host,port,db,user,passwd,charset = 'utf8'): self.host = host self.port = port self.database = db self.user = user self.password = passwd self.charset = charset def connect(self): self.conn = pymysql.connect(host = self.host, port = self.port, user = self.user, password = self.password, database = self.database, charset = self.charset) self.cursor = self.conn.cursor() def close(self): self.cursor.close() self.conn.close() def cud(self, sql, params): try: self.connect() self.cursor.execute(sql, params) self.conn.commit() self.close() except Exception: print("Wrong") def all(self, sql, params): try: self.connect() self.cursor.execute(sql, params) res = self.cursor.fetchall() self.close() return res except Exception: print("Wrong") 使用： 1234567891011from MySQL.MySQLHelper import MySQLHelpername = input("请输入学生姓名")nub = input("请输入学生编号")sql = 'update students set name = %s where id = %s'params = [name, nub]sqlhelper = MySQLHelper('localhost', 3306, 'python3', 'root', '720678')sqlhelper.cud(sql,params) 3. 实例：实现用户登录功能 接收用户输入： 用户名 + 密码 根据用户名，查询密码 未查到： 用户名错误 查到： 匹配密码 匹配失败： 错误 匹配成功： 登录成功 创建表 表的结构： id, uname, upwd, isdelete 需要对密码加密： md5加密：密码包含32个字符 sha1加密： 密码包含40个字符 12345678create table users( id int primary key auto_increment, name varchar(10), password char(40) );insert into users values(1,&apos;hao&apos;,&apos;1d2b703d7a1f59d7d04c1850a2e308810b49b851&apos;); # 密码是123 12345+----+------+------------------------------------------+| id | name | password |+----+------+------------------------------------------+| 1 | hao | 40bd001563085fc35165329ea1ff5c5ecbdbbeef |+----+------+------------------------------------------+ 写登录模块123456789101112131415161718192021from MySQL.MySQLHelper import MySQLHelperfrom hashlib import sha1name = input("请输入用户名： ")pwd = input("请输入密码： ")# 对密码加密s1 = sha1()s1.update(pwd.encode('utf-8'))pwd2 = s1.hexdigest()sql = 'select password from users where name = %s'helper = MySQLHelper('localhost', 3306, 'python3', 'root', '720678')result = helper.all(sql, [name])if len(result) == 0: print("用户名出错")elif result[0][0] == pwd2: print("登录成功")else: print("密码错误") 测试 123请输入用户名： hao请输入密码： 123登录成功 4. MySQL常用语法4.1.创建数据库 语法 用法说明 create database 数据库名字 charset=utf8; 创建数据库 drop database 数据库名字; 删除数据库 use 数据库名字; 使用这个数据库 show databases; 查看当前的所有数据库 select database(); 查看当前正在用的是哪个数据库 4.2.创建数据库下面的表 语法 用法说明 show tables; 查看所有的表 create table 表名(列和其类型); 创建表 desc 表名; 查看表的结构 `alter table 表名 add change drop 列名 类型；` 修改表(增加，修改，删除列) drop table 表名; 删除表 rename table 原表名 to 新表名; 更改表的名字 show create table 表名; 查看表的创建语句 4.3.表格中的数据操作 语法 用法说明 select * from 表名; 查询数据 insert into 表名 values(…); 添加数据（顺序要与表格一致）:全列插入 insert into 表名(列1，..，) values(…); 添加数据（顺序要与表格一致）:指定列插入 insert into 表名 values(),()…; 添加数据：一次性插入多条数据 update 表名 set 列1=值1,… where 条件; 修改数据 delete from 表名 where 条件; 删除数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB语法大全]]></title>
    <url>%2F2019%2F03%2F02%2FMongoDB%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1.MongoDB简介1.1.MongoDB特点 模式自由：可以将不同格式的文档存在同一个数据库中 面向集合的储存： 适合储存JSON风格文件的形式 完整的索引支持：对任何书写可索引 复制和高可用性： 支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制 自动分片： 支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器 丰富的查询： 支持丰富的查询表达方式 快速就地更新：查询优化器会分析查询表达式，并生成一个搞笑的额查询计划 搞笑的传统储存方法，支持二进制数据及大型对象，比如图片 1.2.MongoDB与MySQL的区别 MySQL术语 MongoDB术语 说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接，MongoDB不支持 primary key primary key 主见 1.3.MongoDB三元素 数据库 一个集合的物理容器，一个数据库中科院包含多个文档 文档： 就是SQL的行 一个对象，由键值对组成，是json的扩展 1&#123;&apos;name&apos;:&apos;guojing&apos;, &apos;gender&apos;:&apos;男&apos;&#125; 集合：就是SQL中的表 类似SQL中的表，储存多个文档，结构不固定： 123&#123;&apos;name&apos;:&apos;guojing&apos;, &apos;gender&apos;:&apos;男&apos;&#125;&#123;&apos;name&apos;:&apos;hua&apos;, &apos;age&apos;:20&#125;&#123;&apos;name&apos;:&apos;shxhx&apos;, &apos;hero&apos;:&apos;1998&apos;&#125; 1.4. window中启动mongodb的服务 首先在官网下载安装好数据库 将MongoDB添加到 环境变量 找到MongoDB的bin文件夹：C:\Program Files\MongoDB\Server\4.0\bin 打开计算机-属性-高级系统设置-环境变量-系统变量-path-编辑-粘贴上面的bin地址 在CMD中输入mongo就可以进入服务了 2. 数据库的语法2.1. 数据库语法 代码 说明 db 查看当前数据库 show dbs 查看所有数据库 use 数据库名字 使用数据库(没有的话自动创建) db.dropDatabase() 删除当前数据库 2.1. 集合语法 代码 说明 db.createCollection(集合名字，其他选项) 创建集合 show collections 查看当前数据库的集合 db.集合名字.drop() 删除一个集合 2.2. 支持的数据类型 类型 说明 ObjectID 文档ID：保证文档的唯一性 String 字符串 Boolean 布尔 Integer 整数 Double 浮点 Arrays 数组和列表 Object 嵌入式文档 NULL 存NULL值 Timestamp 时间戳 Date 存当前时间 12# capped是否设置集合大小的上限db.createCollection("sub", &#123;capped: true, size :10&#125;) # capped：true 如果db的容量大于10的话，就会覆盖 3. 数据库的实际操作3.1. 增修删1234567891011121314151617181920212223242526272829303132# 插入db.集合名称.insert(document)db.mask.insert(&#123;'name':'g', gender:1&#125;)# 更改db.集合名称.update( &lt;query&gt;, # 查询条件，类型where &lt;update&gt;, # 更新操作费，类型set &#123;multi:&lt;boolean&gt;&#125; # false：只更新找到的第一条记录,true:修改多行)db.mask.update(&#123;name:'hr'&#125;,&#123;name: 'ceo'&#125;) # 这个会修改整个文档结构，最后用set，只修改值db.mask.update(&#123;&#125;,&#123;$set:&#123;gender:0&#125;&#125;,&#123;multi:true&#125;) # 修改多个数据# 删除db.集合名称.remove( &lt;query&gt;, &#123; justOne:&lt;Boolean&gt; # TRUE：只删除一条，false：删除多条 &#125;)db.mask.remove(&#123;gender:0&#125;,&#123;justOne:true&#125;) # 只删除匹配的第一条db.mask.remove(&#123;&#125;) # 删除所有# 简单查询db.mask.find()# &#123; "_id" : ObjectId("5c6e7e90394099d27b230266"), "name" : "g", "gender" : 1 &#125; 3.2. 查询操作1.基本查询12345678# 基础查询db.集合名称.find(&#123;条件文档&#125;)# 查询只返回一个数据db.集合名称.findOne():# 查询结果格式化db.集合名称.find(&#123;条件文档&#125;).pretty() 1） 比较运算符 等于，直接用属性 + : 小于：$lt 小于等于:$lte 大于: $gt 大于等于: $gte 不等于: ne 1db.mask.find(&#123;count:&#123;$gt:5&#125;&#125;) # count大于5的结果 2）逻辑运算符 and： 不需要写什么，逗号就是了 or：使用$or and和or结合使用 123db.mask.find(&#123;age:&#123;$gte:18&#125;, gender:1&#125;)db.mask.find(&#123;$or:[&#123;age:&#123;$gte:18&#125;,gender:1&#125;]&#125;)db.mask.find(&#123;$or:[&#123;age:&#123;$gte:18&#125;,gender:1&#125;],name:'gj'&#125;) 3）范围运算符 使用$in,$nin判断是否在某个范围内 1db.mask.find(&#123;age:&#123;$in:[18,28]&#125;&#125;) # 年龄为18和28的学生 4）支持正则表达式 使用//或者$regex编写正则表达式 1db.mask.find(&#123;name:&#123;$regex:'^黄'&#125;&#125;) # 查询姓黄的学生 2. 自定义函数查询 使用$where定义函数查询 函数跟JS函数定义是一样的 1db.mask.find($where:function()&#123;return this.age&gt;20&#125;) 3.查询的扩展功能1）Limit + Skip limit：用于读取指定数量的文档，表示获取几条数据 skip: 跳过指定数量的文档，从第几条开始看 12db.mask.find().limit(2) # 只查询两条信息db.mask.find().skip(2) # 查询从第三条开始的信息 2）投影 在查询返回的结果中，只选择必要的字段，而不是选择一个文档的整个字段—-投影 在find的第二个参数中去写 123db.集合名称.find(&#123;&#125;,&#123;字段名称:1,...&#125;) # 需要显示的字段，设置为1db.mask.find(&#123;&#125;,&#123;_id:0, name:1,gender:1&#125;) 3）排序 sort方法 1db.mask.find().sort(&#123;age:-1&#125;) # 1为升序，-1为降序 3）统计个数 count()方法 123db.集合名称.count(&#123;条件&#125;)db.mask.count(&#123;age:&#123;gt:20&#125;&#125;) 3）消除重复 distinct() 去重复 123db.集合名称.distinct('去重字段'，&#123;条件&#125;)db.mask.distinct(gender,&#123;age:&#123;$gt:20&#125;&#125;) # age大于20的进行消除重复 4.MongoDB的高级操作主要讲解这个数据库的高级操作，包括聚合、主从复制、分片、备份和恢复、MR、与python的交互 4.1. 聚合aggregate 用于计算数据，类型sum()和avg（） 1db.集合名称.aggregate([&#123;管道:&#123;表达式&#125;&#125;]) 管道的含义： 将前一次操作的输出结果作为下一个命令的输入 常用管道有： $group:将集合中的文档分组，用于统计结果 $match:过滤数据，只输出符合条件的文档 $project:修改输入文档的结果 $sort:将输入文档排序后输出 $limit:限制聚合管道返回的文档数 $skip:跳过指定数量的文档 $unwind:将数组类型的字段进行拆分 表达式： 处理输入文档并输出 1表达式：'$列名' 常用表达式为： $sum: 计算总数 $avg: $min: $max: $push:在结果文档中插入值到另外一个数组中 $first:根据资源文档的排序获取第一个文档数据 $last:根据资源文档的排序获取最后一个文档数据4.1.1. $group 将集合中的文档分组，用于统计结果 _id表示分组的依据，使用某个字段的格式为’$字段’ 123456789# 统计男生，女生的总人数db.mask.aggregate([ &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125; &#123;$group:&#123;_id:'$gender',counter:&#123;$avg:'age'&#125;&#125;&#125; # gender分组，对age求和 &#123;$group:&#123;_id:'$gender',counter:&#123;$frist:'age'&#125;&#125;&#125; # 拿到第一个值 # push--透视数据 &#123;$group:&#123;_id:'$gender',counter:&#123;$push:'age'&#125;&#125;&#125; # 将基于gender的分组结果放到数组中 &#123;$group:&#123;_id:'$gender',counter:&#123;$push:'$$ROOT'&#125;&#125;&#125; # 查看文档所有内容(gender分组情况下) ]) Group by null 将这个集合数据分成一组 123db.mask.aggregate( &#123;$group:&#123;_id:null,counter:&#123;$sum:1&#125;&#125;&#125;) 4.1.2. $match 用于过滤数据 4.1.3.$project 将结果集中的一部分拿出来显示 4.1.4. $sort 用于排序 4.1.5. $limit+skip4.1.6. $unwind 将文档中的某个数组类型字段拆分成多条，每条包含数组中的一个值 1db.集合名称.aggregate([&#123;$unwind:'$字段名称'&#125;]) 12345678910111213db.mask.aggregate([] # 管道1：过滤数据 &#123;$match:&#123;age:&#123;$gt:20&#125;&#125;&#125;, # 查询大于20的信息 # 管道2：分组数据 &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, # 管道3：设置显示哪些数据 &#123;$project:&#123;_id:0,name:1,age:1&#125;&#125;, # 管道4：数据排序 &#123;$sort:&#123;_id:1&#125;&#125;, # 管道5： 跳过多少数据 &#123;$skip:1&#125;, &#123;$limit:1&#125;,]) 4.2. 索引 在大量数据中快速查找 步骤一：创造大量数据 123for(i=0;i&lt;100000,i++)&#123; db.mask.insert(name:'test' + i, age:i)&#125; 步骤二：数据查找性能分析 查找姓名为test10000的文档,并通过explain()来进行性能分析 1db.mask.find(&#123;name:'test10000'&#125;).explain('executionStats') # 整体查询时间，96毫秒 步骤三：创建索引 1234db.集合.ensureIndex(&#123;属性:1&#125;) # 1表示升序 db.mask.ensureIndex(&#123;"name":1&#125;)db.mask.find(&#123;name:'test10000'&#125;).explain('executionStats') # 2毫秒 索引命令 建立单一索引 1db.mask.ensureIndex(&#123;"name":1&#125;,&#123;"unique": true&#125;) 建立多个索引 1db.mask.ensureIndex(&#123;"name":1，"age":1&#125;) 查看所有索引 123db.mask.getIndexes()db.mask.dropIndexes(‘索引名称’) # 删除 4.3. 安全:超级管理员和普通用户创建 创建超级管理员 为了更安全的访问MongoDB，需要访问者提供用户名和密码，所以我们需要在mongodb中创建用户，mongoDB采用了角色-用户-数据库的安全管理方式，每个用户被分配了一个角色，不同角色有不同的管理权限，常用角色为如下： root: 只在admin数据库中可用，超级管理员 read：读 readwrite：读写 下面我们来创建超级管理员： 123456use adminad.createUser(&#123; user:'admin', pwd:'123' roles:[&#123;role:'root',db:'admin'&#125;]&#125;) 修改配置文件，启用身份验证 修改配置文件C:\Program Files\MongoDB\Server\4.0\bin\mongod.cfg 查找security字段并重写为： 12security: authorization: enabled 重启服务 1mongo restart # 重启服务 使用超级管理员登录 1mongo -u admin -p 123 --authenticationDatabase admin 里面有以下列表 system.Users:通过db.system.Users.find()查看所有的user信息 system.version 为普通用户创建一个数据库 1use test1 创建普通用户 从超级管理员那里创建一个普通用户账户(无法访问超级数据库) 12345db.createUser(&#123; user:'t1', pwd:'123', roles:[&#123;role:'readWrite', db:'test1'&#125;]&#125;) 使用普通用户登录 为普通用户授权test1的数据库权限 1mongo -u t1 -p 123 -authenticationDatabase test1 4.4. 数据备份和恢复4.1. MongoDB复制复制的工作原理 复制至少需要两个节点A，B… A是主节点，负责处理客户端请求 其余的是从节点，负责复制主节点上的数据 节点的常见搭配方式是：一主一从、一主多从 主节点记录在其上的操作，从节点定期轮询主机诶单获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致 主节点与丛节点进行数据交互保障数据的一致性 复制的特点 N个节点的集群 任何节点可作为主节点 所有写入操作都在主节点 自动故障转移 自动恢复]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB和Python的交互]]></title>
    <url>%2F2019%2F03%2F02%2FMongoDB%E5%92%8CPython%E7%9A%84%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[安装pymongo包 1pip install pymongo 1.MongoDB和Python交互1.1. 连接mongoDB服务器-MongoClient 建立连接并创建客户端 1234# 无安全验证 client = MongoClient('mongodb://localhost:27017/database_name')# 有安全验证client = MongoClient('mongodb://user:pwd@localhost:27017/databse_name') 获取数据库-database 1db = client.py 数据库的方法-类Collection 主要方法有： insert_one insert_many update_one update_many delete_one delete_many find_one find 1234567891011121314151617181920212223# 获取集合stustu = db.stu# 添加文档，返回文档ids1 = &#123;'name':'张三','gender':True&#125;s1_id = stu.insert_one(s1).insert_idprint(s1_id)# 修改文档stu.update_one(&#123;'name':'张三'&#125;,&#123;'$set':&#123;'name':'张三的爸爸'&#125;&#125;)# 删除文档 stu.delete_one(&#123;'name':'张三的爸爸'&#125;)# 查找一个文档，将文档转换为一个元组返回 s2 = stu.find_one(&#123;'name':'李四'&#125;)# 查询多个文档，返回一个Cursor类型对象，用于遍历返回元组形式的文档cursor = stu.find(&#123;'hometown':'重庆'&#125;)# 排序，返回Cursor类型对象 cursor = stu.find().sort('age',DESCENDING)cursor = stu.find().sort([('age',DESCENDING),'name',ASCENDING])]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的基础语法]]></title>
    <url>%2F2019%2F03%2F02%2FJava%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 基本概念1.1. 环境变量环境变量通常是指在操作系统(win10,win7)中，用来指定操作系统运行时需要的一些参数(比如一个国家需要人民，货币，货物…)，一般为一些键值对 Path环境变量的作用-&gt;寻找命令Path环境变量是操作系统外部命令搜索路径 classpath变量的作用-&gt;寻找类文件 1.2. JDK里面有什么？ 1.3. 什么是JRE？JRE是JAVA运行的环境，包括以下几个部分： Java虚拟机： 它是由一个软件虚拟出来的计算机 Java平台核心类文件 其他支持文件 2.Java的基本语法12345678/* 这是一个注释*/public class ClassName&#123; public static void main(String[] args)&#123; object.method(parameters) &#125;&#125; 技巧：在IDEA中输入psvm会直接创建main函数 2.1 Java的数据类型java是一种强类型语言，这就意味着必须为每个变量声明一种类型 整型: int, short, long, byte 浮点型: float, double char类型: 用单引号 boolean类型 2.2. 变量2.2.1. 变量的声明方法声明变量的语法如下：1int var=10; 2.2.2. 常量final123456789public class Main &#123; // 类常量用static final定义 public static final double PRESEM = 2.54; public static void main(String[] args) &#123; //基本常量用final定义 final int jbg = 12; System.out.println("Hello World!"); &#125;&#125; 2.3. 运算符 数学运算符，+,-,*,/ 数学函数与常量: Math.sqrt(),Math.pow(),Math.sin(),Math.tan(),Math.exp().Math.log(),Math.PI 强制类型转换 12double x =9.98;int nx = (int) x; 2.4. 字符串字符串是不可变字符串，无法直接修改但是我们可以修改字符串变量，让他引用另外一个字符串，达到修改的效果 123456789String greet = "Hello";// 子串String s = greet.substring(0,3);// 拼接String msg = greet + "friends";// 判断是否相等greet.equals("help");//判断空串和Null串if(greet!= null &amp;&amp; greet.lend()!=0); 2.4.1. 字符串构造器有时候我们需要一段一段的构造一个字符串，那么我们就可以通过一个字符串构建器来创造1234567//构造字符串构建器StringBuilder builder = new StringBuilder();//添加字符串builder.append(ch);builder.append(ch2);//转换成真正的字符串String finalString = builder.toString(); 2.5. 输入输出2.5.1. 键盘输入读取输入流System.in需要以下两个步骤 创建Scanner对象，并关联System.in 通过Scanner对象的nextLine(),next(),nextInt()方法读取数据 最后通过hasNext(),hasNextInt(),hasNextDouble()判断是否读取完 12345678910111213public class test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("What is your name?"); String name = in.nextLine(); System.out.println("What is your age?"); int age = in.nextInt(); System.out.println("Hello, " + name + ". you age is " + age); &#125;&#125; 2.5.2. 格式化输出1System.out.printf("hello, %s, you age is %d", name,age) 2.5.3. 文件输入和输出文件读取 要想对文件进行读取，有以下几个步骤 用File对象构造一个Scanner对象 通过Scanner对象的nextLine(),next(),nextInt()方法读取数据 12Scanner in = new Scanner(Path.get("C:\\mydirectory\\myfile.txt"), "UTF-8");String msg = in.nextLine(); 文件写入 PrinterWriter out = new PrinterWriter(“myfile.txt”, “UTF-8”) 2.6. 循环控制流程 2.7. 数组 数组是一种数据结构，用来储存同一类型值得集合，通过一个整型下标就可以访问数组中的每个值，如果a是一个整型数组，a[i]就是数组中下标为i的整数 数组是用来储存同一数据类型的集合 一旦创建，不可改变大小 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) throws IOException &#123; // 创建数组，指定数组长度(不可更改),创建后，所有元素初始化为0，布尔为false， 对象数组为null int[] a = new int[10]; // 给数组赋值 for (int i=0; i&lt;a.length; i++)&#123; a[i] = i; &#125; // foreach循环 for (int element: a)&#123; System.out.println(element); &#125; // 数组初始化(无需指定长度) int[] b = &#123;1,3,5,8,6,12&#125;; // 数组拷贝(指向内存同一个区域) int[] c = b; int[] c_hard_copy = Arrays.copyOf(b, b.length); // 数组排序 Arrays.sort(b); // 命令行参数 在main方法中的String[] args就是一个字符串数组，接收一系列命令行参数 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django的基本用法教程-Part-I]]></title>
    <url>%2F2019%2F03%2F02%2FDjango%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%95%99%E7%A8%8B-Part-I%2F</url>
    <content type="text"><![CDATA[1. Django基础1.1. Django简介1.2. Django安装1234pip install Djangoimport djangoprint(django.get_version()) # 2.1.7 1.3. 创建Django项目在你希望创建django项目的文件夹下输入1django-admin startproject mysite mysite项目下面有如下的文件1234567mysite/ manage.py # 管理 Django 项目的命令行工具 mysite/ __init__.py # 一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包 settings.py # Django 项目的配置文件 urls.py # Django 项目的 URL 声明 wsgi.py # 项目的运行在 WSGI 兼容的Web服务器上的入口 在mysite文件夹内运行1python manage.py runserver # 启动了一个自带的简易服务器 现在，服务器正在运行，浏览器访问 https://127.0.0.1:8000/。你将会看到一个“祝贺”页面，随着一只火箭发射，服务器已经运行了。 1.4. 创建一个应用你的应用可以存放在任何 Python path 中定义的路径。在这个教程中，我们将在你的 manage.py 同级目录下创建投票应用。这样它就可以作为顶级模块导入，而不是 mysite 的子模块。 创建应用： 1python manage.py startapp polls 这将会创建一个 polls 目录，它的目录结构大致如下： 123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 1.5. 创建第一个视图让我们开始编写第一个视图吧。打开 polls/views.py，把下面这些 Python 代码输入进去： 12345from django.http import HttpResponsedef index(request): return HttpResponse("Hello, world. You're at the polls index.") 这是 Django 中最简单的视图。如果想看见效果，我们需要将一个 URL 映射到它——这就是我们需要 URLconf 的原因了。为了创建 URLconf，请在 polls 目录里新建一个 urls.py 文件。你的应用目录现在看起来应该是这样 12345678910polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py urls.py views.py 在 polls/urls.py 中，输入如下代码： 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下： 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 函数 include() 允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到URLconf 以供进一步处理 你现在把 index 视图添加进了 URLconf。可以验证是否正常工作 用你的浏览器访问 http://localhost:8000/polls/来检查 函数path的使用函数 path() 具有四个参数，两个必须参数：route和 view，两个可选参数：kwargs 和 name。现在，是时候来研究这些参数的含义了。 route: route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项 view:当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 kwargs: 任意个关键字参数可以作为一个字典传递给目标视图函数。 name: 为你的 URL 取名能使你在 Django 的任意地方唯一地引用它 2. Django的数据库部分2.1. 数据库配置现在，打开 mysite/settings.py 。这是个包含了 Django 项目设置的 Python 模块。通常默认SQLite数据库 在数据库中创建表1python manage.py migrate 这个 migrate 命令检查 INSTALLED_APPS 设置，为其中的每个应用创建需要的数据表，至于具体会创建什么，这取决于你的 mysite/settings.py 设置文件和每个应用的数据库迁移文件 这个命令所执行的每个迁移操作都会在终端中显示出来 2.2. 创建模型定义模型 - 也就是数据库结构设计和附加的其它元数据。 在这个简单的投票应用中，需要创建两个模型：问题 Question 和选项 Choice。Question 模型包括问题描述和发布时间。Choice 模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。 polls/models.py 文件 中编写如下代码 123456789101112131415161718192021222324from django.db import models# Create your models here.# 每个模型被表示为 django.db.models.Model 类的子类class Question(models.Model): # 每个模型有一些类变量，它们都表示模型里的一个数据库字段。 # 每个字段都是 Field 类的实例，告诉 Django 每个字段要处理的数据类型。 # 字符字段被表示为 CharField question_text = models.CharField(max_length=200) # 日期时间字段被表示为 DateTimeField pub_date = models.DateTimeField('date published') def __str__(self): return self.question_textclass Choice(models.Model): # 使用 ForeignKey 定义了一个关系。这将告诉 Django，每个 Choice 对象都关联到一个 Question 对象。 # Django 支持所有常用的数据库关系：多对一、多对多和一对一。 question = models.ForeignKey(Question, on_delete = models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) def __str__(self): return self.choice_text 2.3. 激活模型通过上述代码，djanao可以 为这个应用创建数据库 schema（生成 CREATE TABLE 语句） 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API 但是首先得把 polls 应用安装到我们的项目里 为了在我们的工程中包含这个应用，我们需要在配置类 INSTALLED_APPS 中添加设置。因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样： 123456789INSTALLED_APPS = [ &apos;polls.apps.PollsConfig&apos;, &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;,] 然后为polls创建数据库 1python manage.py makemigrations polls 通过运行 makemigrations 命令，Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次 迁移。 Django 有一个自动执行数据库迁移并同步管理你的数据库结构的命令 - 这个命令是 migrate，我们马上就会接触它 - 但是首先，让我们看看迁移命令会执行哪些 SQL 语句。sqlmigrate 命令接收一个迁移的名称，然后返回对应的 SQL： 1python manage.py sqlmigrate polls 0001 输出： 123456789101112131415161718192021222324252627282930BEGIN;---- Create model Choice--CREATE TABLE "polls_choice" ( "id" serial NOT NULL PRIMARY KEY, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL);---- Create model Question--CREATE TABLE "polls_question" ( "id" serial NOT NULL PRIMARY KEY, "question_text" varchar(200) NOT NULL, "pub_date" timestamp with time zone NOT NULL);---- Add field question to choice--ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");ALTER TABLE "polls_choice" ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id" FOREIGN KEY ("question_id") REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED;COMMIT; 数据库的表名是由应用名(polls)和模型名的小写形式( question 和 choice)连接而来 主键(IDs)会被自动创建 默认的，Django 会在外键字段名后追加字符串 “_id” 。 外键关系由 FOREIGN KEY 生成。你不用关心 DEFERRABLE 部分，它只是告诉 PostgreSQL，请在事务全都执行完之后再创建外键关系。 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment (MySQL)、 serial (PostgreSQL)和 integer primary key autoincrement (SQLite)，Django 会帮你自动处理 这个 sqlmigrate 命令并没有真正在你的数据库中的执行迁移 - 它只是把命令输出到屏幕上，让你看看 Django 认为需要执行哪些 SQL 语句。 现在，再次运行 migrate 命令，在数据库里创建新定义的模型的数据表： 12345python manage.py migrate# Operations to perform:# Apply all migrations: admin, auth, contenttypes, polls, sessions# Running migrations:# Applying polls.0001_initial... OK 这个 migrate 命令选中所有还没有执行过的迁移（Django 通过在数据库中创建一个特殊的表 django_migrations 来跟踪执行过哪些迁移）并应用在数据库上 - 也就是将你对模型的更改同步到数据库结构上。 迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。 现在，你只需要记住，改变模型需要这三步： 编辑 models.py 文件，改变模型。 运行 python manage.py makemigrations 为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 2.4. 初试 API现在让我们进入交互式 Python 命令行，尝试一下 Django 为你创建的各种 API。通过以下命令打开 Python 命令行 1python manage.py shell 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; from polls.models import Choice, Question # Import the model classes we just wrote.# No questions are in the system yet.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# Create a new Question.# Support for time zones is enabled in the default settings file, so# Django expects a datetime with tzinfo for pub_date. Use timezone.now()# instead of datetime.datetime.now() and it will do the right thing.&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())# Save the object into the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()# Now it has an ID.&gt;&gt;&gt; q.id1# Access model field values via Python attributes.&gt;&gt;&gt; q.question_text"What's new?"&gt;&gt;&gt; q.pub_datedatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)# Change values by changing the attributes, then calling save().&gt;&gt;&gt; q.question_text = "What's up?"&gt;&gt;&gt; q.save()# objects.all() displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt; 2.5. 介绍Django的管理页面创建一个管理员账号1python manage.py createsuperuser 12345Username: adminEmail address: admin@example.comPassword: **********Password (again): *********Superuser created successfully. 启动开发服务器Django 的管理界面默认就是启用的。让我们启动开发服务器，看看它到底是什么样的。 1python manage.py runserver 现在，打开浏览器，转到你本地域名的 “/admin/“ 目录， – 比如 “http://127.0.0.1:8000/admin/“ 。你应该会看见管理员登录界面： 进入管理页面通过密码进入页面如下 你将会看到几种可编辑的内容：组和用户。它们是由 django.contrib.auth 提供的，这是 Django 开发的认证框架 向管理页面加入投票应用告诉管理页面，问题 Question 对象需要被管理。打开 polls/admin.py 文件，把它编辑成下面这样 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 3. 视图3.1. 什么是视图视图的概念是「一类具有相同功能和模板的网页的集合」。比如，在一个博客应用中，你可能会创建如下几个视图 博客首页——展示最近的几项内容。 内容“详情”页——详细展示某项内容。 以年为单位的归档页——展示选中的年份里各个月份创建的内容 评论处理器——用于响应为一项内容添加评论的操作。 而在我们的投票应用中，我们需要下列几个视图 问题索引页——展示最近的几个投票问题 问题详情页——展示某个投票的问题和不带结果的选项列表。 问题结果页——展示某个投票的结果。 投票处理器——用于响应用户为某个问题的特定选项投票的操作。 在 Django 中，网页和其他内容都是从视图派生而来。每一个视图表现为一个简单的 Python 函数 一个 URL 模式定义了某种 URL 的基本格式——举个例子：/newsarchive/&lt;year&gt;/&lt;month&gt;/。 为了将 URL 和视图关联起来，Django 使用了 ‘URLconfs’ 来配置。URLconf 将 URL 模式映射到视图。 3.2. 编写更多视图在让我们向 polls/views.py 里添加更多视图。这些视图有一些不同，因为他们接收参数： 123456789def detail(request, question_id): return HttpResponse("You're looking at question %s." % question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." % question_id) 把这些新视图添加进 polls.urls 模块里，只要添加几个 url() 函数调用就行： 1234567891011121314from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 然后看看你的浏览器，如果你转到 “/polls/34/“ ，Django 将会运行 detail() 方法并且展示你在 URL 里提供的问题 ID。再试试 “/polls/34/vote/“ 和 “/polls/34/vote/“ ——你将会看到暂时用于占位的结果和投票页。 当某人请求你网站的某一页面时——比如说， “/polls/34/“ ，Django 将会载入 mysite.urls 模块，因为这在配置项 ROOT_URLCONF 中设置了。然后 Django 寻找名为 urlpatterns 变量并且按序匹配正则表达式。在找到匹配项 ‘polls/‘，它切掉了匹配的文本（”polls/“），将剩余文本——“34/“，发送至 ‘polls.urls’ URLconf 做进一步处理。在这里剩余文本匹配了 ‘int:question_id/‘，使得我们 Django 以如下形式调用 detail(): 1detail(request=&lt;HttpRequest object&gt;, question_id=34) 3.3. 写一个真正的视图 每个视图必须的两个步骤 返回一个包含请求页面内容的HttpResponse对象 抛出异常Http404 其他你自己定义的操作 你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 Django 自带的，或者其他第三方的），可以生成一个 PDF 文件，可以输出一个 XML，创建一个 ZIP 文件，你可以做任何你想做的事，使用任何你想用的 Python 库。 首先，在你的 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。 你项目的 TEMPLATES 配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls 的模板位置的原因。 在你刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，所以你只需要使用 polls/index.html 就可以引用到这一模板了。 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href="/polls/&#123;&#123; question.id &#125;&#125;/"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板： 123456789from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 用你的浏览器访问 “/polls/“ ，你将会看见一个无序列表 3.4. 抛出404错误现在，我们来处理投票详情视图——它会显示指定投票的问题标题。下面是这个视图的代码： 1234def detail(request, question_id): # 试用 get() 函数获取一个对象，如果不存在就抛出 Http404 question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;)]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程6-Shape和Selector结合用于自定义控件]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B6-Shape%E5%92%8CSelector%E7%BB%93%E5%90%88%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.Selector和hape的说明 在Android开发中，使用shape可以很方便的帮我们画出想要的背景，相对于png图片来说，使用shape可以减少安装包的大小，而且能够更好的适配不同的手机。 Selector（背景选择器）主要是用来改变一个按钮控件的背景 一般使用如下格式自定义控件 1234567891011&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;Shape&gt; &lt;/Shape&gt; &lt;/item&gt;&lt;/selector &gt; 2. Shape的使用首先看官网的说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] //共有4种类型，矩形（默认）/椭圆形/直线形/环形 // 以下4个属性只有当类型为环形时才有效 android:innerRadius="dimension" //内环半径 android:innerRadiusRatio="float" //内环半径相对于环的宽度的比例，比如环的宽度为50,比例为2.5,那么内环半径为20 android:thickness="dimension" //环的厚度 android:thicknessRatio="float" //环的厚度相对于环的宽度的比例 android:useLevel="boolean"&gt; //如果当做是LevelListDrawable使用时值为true，否则为false. &lt;corners //定义圆角 android:radius="dimension" //全部的圆角半径 android:topLeftRadius="dimension" //左上角的圆角半径 android:topRightRadius="dimension" //右上角的圆角半径 android:bottomLeftRadius="dimension" //左下角的圆角半径 android:bottomRightRadius="dimension" /&gt; //右下角的圆角半径 &lt;gradient //定义渐变效果 android:type=["linear" | "radial" | "sweep"] //共有3中渐变类型，线性渐变（默认）/放射渐变/扫描式渐变 android:angle="integer" //渐变角度，必须为45的倍数，0为从左到右，90为从上到下 android:centerX="float" //渐变中心X的相当位置，范围为0～1 android:centerY="float" //渐变中心Y的相当位置，范围为0～1 android:startColor="color" //渐变开始点的颜色 android:centerColor="color" //渐变中间点的颜色，在开始与结束点之间 android:endColor="color" //渐变结束点的颜色 android:gradientRadius="float" //渐变的半径，只有当渐变类型为radial时才能使用 android:useLevel=["true" | "false"] /&gt; //使用LevelListDrawable时就要设置为true。设为false时才有渐变效果 &lt;padding //内部边距 android:left="dimension" android:top="dimension" android:right="dimension" android:bottom="dimension" /&gt; &lt;size //自定义的图形大小 android:width="dimension" android:height="dimension" /&gt; &lt;solid //内部填充颜色 android:color="color" /&gt; &lt;stroke //描边 android:width="dimension" //描边的宽度 android:color="color" //描边的颜色 // 以下两个属性设置虚线 android:dashWidth="dimension" //虚线的宽度，值为0时是实线 android:dashGap="dimension" /&gt; //虚线的间隔&lt;/shape&gt; 2.1. 直角与圆角矩形1234567891011121314&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:radius="10dp"/&gt; &lt;solid android:color="@color/holo_green_dark"/&gt; &lt;stroke android:width="2dp" android:color="@color/white"/&gt;&lt;/shape&gt; 2.2. 圆形1234567891011&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;gradient android:type="linear" android:angle="45" android:startColor="@color/holo_green_dark" android:centerColor="@color/holo_blue_dark" android:endColor="@color/holo_blue_bright"/&gt;&lt;/shape&gt; 3. Selector和Shape的结合使用通过实现一个按钮，按下前和按下后的不同变化来演示这个功能 创建正常状态下的button样式button_default.xml，可用未点击 1234567891011121314151617181920212223&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;gradient android:angle="45" android:startColor="#6a938b" android:endColor="#051c3b"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建点击状态下的样式buttom_pressed.xml 12345678910111213141516171819202122&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;gradient android:angle="45" android:startColor="#9a5edf" android:endColor="#20549b"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建不可用状态下的样式buttom_disabled.xml 1234567891011121314151617181920&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;solid android:color="#858687"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建一个selector来关联这些shape：custeom_button.xml 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="false" android:state_enabled="true" android:drawable="@drawable/button_default"/&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/button_pressed"/&gt; &lt;item android:state_enabled="false" android:drawable="@drawable/button_disabled"/&gt;&lt;/selector&gt; 在主button中引入这个selector 12345678910111213&lt;Button android:id="@+id/custom_choose" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="10dp" android:background="@drawable/custom_button" /&gt;&lt;Switch android:id="@+id/if_enable" android:layout_width="wrap_content" android:layout_height="wrap_content" android:checked="true" android:text="Enabled"/&gt; 在主活动中写入逻辑关系 123456789101112131415161718192021222324252627282930313233public class CustomActivity extends AppCompatActivity &#123; private Button custom_BT; private Switch if_checked; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_custom); custom_BT = (Button)findViewById(R.id.custom_choose); if_checked = (Switch)findViewById(R.id.if_enable); custom_BT.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(CustomActivity.this,"CLicked", Toast.LENGTH_SHORT).show(); &#125; &#125;); if_checked.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked)&#123; custom_BT.setEnabled(true); &#125;else &#123; custom_BT.setEnabled(false); &#125; &#125; &#125;); &#125;&#125; 4. 通过Style保存刚刚设计的样式1234&lt;style name="CustomButton" parent="Widget.AppCompat.Button"&gt; &lt;item name = "android:background"&gt;@drawable/custom_button&lt;/item&gt; &lt;item name = "android:textColor"&gt;#fff&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程5-数据存储]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B5-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[1. 持久化技术 将那些内存的瞬间数据保存到存储设备中，保证即使在手机或者电脑关机的状态下，数据不会丢失， Android有三种持久化方式 文件存储 SharedPreference储存 数据库储存 2. 文件储存适用于存储一些简单的额文本数据或者二进制数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class DataSaveActivity extends AppCompatActivity &#123; EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_data_save); editText = (EditText)findViewById(R.id.edit); // 当从主活动转到这里的时候，会加载上一步的文本 String inputText = load(); // !TextUtils.isEmpty(inputText):当传入的字符串登录null或者空的时候，返回trye if (!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); Toast.makeText(this, "Restoring success", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = editText.getText().toString(); save(inputText); &#125; // 将数据保存到文件中 // Context类体用了一个openFileOutput()方法，用于数据储存到指定文件 // 输入参数: 1: 文件名，所有文件都默认放在/data/data/&lt;package name&gt;/files目录下 // 2: 文件操作模式，private和append public void save(String inputText)&#123; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput("data", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); Toast.makeText(this, "Text has been saved", Toast.LENGTH_SHORT).show(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if (writer !=null)&#123; writer.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; // 从文件中读取数据 // Context类提供一个openFileInput方法用于从文件读取数据，接收一个参数：文件名 // 系统自动从/data/data/&lt;package name&gt;/files/目录下去加载这个文件，返回一个FileInputStream对象 // 通过java流将数据读取出来 public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content =new StringBuilder(); try&#123; in = openFileInput("data"); // 通过BufferedReader进行一行行的读取 reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while ((line = reader.readLine())!=null)&#123; content.append(line); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if (reader!=null)&#123; try&#123; reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125; &#125; 3. SharedPreferences存储 SharedPreference是通过键值对存储数据 3.1. 将数据存储到Sharepreferences中要想适用SharePreference来存储数据，首先需要获得SharePreference对象，Android提供了3中方式获取SharePreference对象 Context类中的getSharedPreferences(filename, MODE)方法 第一个参数是用于指定SharedPreferences的文件名称，保存在/data/data/&lt;package name&gt;/shared_prefs/目录下第二个参数是默认操作模式，MODE_PRIVATE Activity类中的getPreferences()方法 这个方法和上面的很类似，不过它只接收一个操作模式参数 PrefenceManager类中的getDefaultSharedPreferences()方法 这是一个静态方法接收context参数，并自动使用当前程序包名作为前缀来命名SharedPreferences文件 得到了SharePreference对象后，我们就可向里面写入数据了，主要分为3步完成： (1). 调用SharePreference对象的edit()方法获取一个SharePreferences.Editor对象(2). 向SharePreferences.Editor对象添加数据，putBoolean(),putString()(3). 调用apply()方法将添加的数据提交，完成数据的存储操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class DataSaveActivity extends AppCompatActivity &#123; private EditText editText,account,pw; private Button login; private CheckBox rememberPW; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_data_save); editText = (EditText)findViewById(R.id.edit); account = (EditText)findViewById(R.id.account); pw = (EditText)findViewById(R.id.pw); login = (Button)findViewById(R.id.login); rememberPW = (CheckBox)findViewById(R.id.remeber_pw); pref = PreferenceManager.getDefaultSharedPreferences(this); boolean isRemember = pref.getBoolean("remember_password",false); if (isRemember)&#123; String accountText = pref.getString("account",""); String passwordText = pref.getString("password", ""); account.setText(accountText); pw.setText(passwordText); rememberPW.setChecked(true); &#125; login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String accountText = account.getText().toString(); String passwordText = pw.getText().toString(); // 如果账号是admin，且密码是123456，就任务登录成功 if (accountText.equals("admin") &amp;&amp; passwordText.equals("123456"))&#123; editor = pref.edit(); if (rememberPW.isChecked())&#123; editor.putBoolean("remember_password", true); editor.putString("account", accountText); editor.putString("password",passwordText); &#125; else &#123; editor.clear(); &#125; editor.apply(); Toast.makeText(DataSaveActivity.this, "You got it", Toast.LENGTH_SHORT).show(); &#125; else&#123; Toast.makeText(DataSaveActivity.this, "Wrong account or password", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); // 当从主活动转到这里的时候，会加载上一步的文本 String inputText = load(); // !TextUtils.isEmpty(inputText):当传入的字符串登录null或者空的时候，返回trye if (!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); Toast.makeText(this, "Restoring success", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = editText.getText().toString(); save(inputText); &#125; // 将数据保存到文件中 // Context类体用了一个openFileOutput()方法，用于数据储存到指定文件 // 输入参数: 1: 文件名，所有文件都默认放在/data/data/&lt;package name&gt;/files目录下 // 2: 文件操作模式，private和append public void save(String inputText)&#123; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput("data", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); Toast.makeText(this, "Text has been saved", Toast.LENGTH_SHORT).show(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if (writer !=null)&#123; writer.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; // 从文件中读取数据 // Context类提供一个openFileInput方法用于从文件读取数据，接收一个参数：文件名 // 系统自动从/data/data/&lt;package name&gt;/files/目录下去加载这个文件，返回一个FileInputStream对象 // 通过java流将数据读取出来 public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content =new StringBuilder(); try&#123; in = openFileInput("data"); // 通过BufferedReader进行一行行的读取 reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while ((line = reader.readLine())!=null)&#123; content.append(line); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if (reader!=null)&#123; try&#123; reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125;&#125; 4. LitePal数据库存储LitPal是一款开源的Android数据库框架，采用对象关系映射(ORM)模式，并将我们平时开发常用的一些数据库功能进行了一些封装 4.1. 配置LitePal在app/build.gradle中添加implments 123dependencies &#123; implementation &apos;org.litepal.android:java:3.0.0&apos;&#125; 然后需要配置litepal.xml文件，右击app/src/main目录-&gt;New-&gt;Directory创建一个assets目录，然后在里面创建litepal.xml文件 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value = "BookStore"&gt;&lt;/dbname&gt; &lt;version value = "1"&gt;&lt;/version&gt; &lt;list&gt;&lt;/list&gt; &lt;/litepal&gt; 然后在AndroidManifest.xml中配置一下android:name=&quot;org.litepal.LitePalApplication&quot; 4.2. 创建和升级数据库首先配置adb C:\Users\HAO\AppData\Local\Android\Sdk\platform-tools添加到系统变量中]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程4-BroadcastReceiver的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B4-BroadcastReceiver%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 广播机制BroadcastReceiver，顾名思义就是“广播接收者”的意思，它是Android四大基本组件之一，这种组件本质上是一种全局的监听器，用于监听系统全局的广播消息。它可以接收来自系统和应用的的广播。 BroadcastReceiver用于接收程序（包括系统程序和一般应用）通过sendBroadcast()方法发出的Broadcast intents Android的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就会只接收自己关系的广播内容 广播内容来自系统或者其他应用程序 发送广播:Intent 接收广播: Broadcaset Receiver 广播的分类 标准广播：异步执行，广播发出后，所有的接收器几乎同时接收到这个广播，没有先后顺序之分 有序广播： 同步执行，广播发出后，同意时间只有一个广播接收器能够接受这个广播，当接收完毕后才会继续传递给下一个 2.程序启动BroadcastReceiver的步骤： 创建需要启动BroadcastReceiver的Intent。 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver。其中sendBroadcast发送的是普通广播，sendOrderedBroadcast发送的是有序广播。 3.创建BroadcastReceiver的步骤3.1. 创建BroadcastReceiver的自雷由于BroadcastReceiver本质上是一种监听器，所以创建BroadcastReceiver的方法也非常简单，只需要创建一个BroadcastReceiver的子类然后重写onReceive (Context context, Intentintent)方法即可。 3.2. 注册BroadcastReceiver一旦实现了BroadcastReceiver，接下就应该指定该BroadcastReceiver能匹配的Intent即注册BroadcastReceiver。注册BroadcastReceiver的方式有两种： 静态注册： 这种方法是在配置AndroidManifest.xml配置文件中注册，通过这种方式注册的广播为常驻型广播，也就是说如果应用程序关闭了，有相应事件触发，程序还是会被系统自动调用运行 1234567&lt;!-- 在配置文件中注册BroadcastReceiver能够匹配的Intent --&gt;&lt;receiver android:name="com.example.test.MyBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MyBroadcastReceiver"&gt;&lt;/action&gt; &lt;category android:name="android.intent.category.DEFAULT"&gt;&lt;/category&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册: 种方法是通过代码在.Java文件中进行注册。通过这种方式注册的广播为非常驻型广播，即它会跟随Activity的生命周期，所以在Activity结束前我们需要调用unregisterReceiver(receiver)方法移除它。 123456//通过代码的方式动态注册MyBroadcastReceiverMyBroadcastReceiver receiver=new MyBroadcastReceiver();IntentFilter filter=new IntentFilter();filter.addAction("android.intent.action.MyBroadcastReceiver");//注册receiverregisterReceiver(receiver, filter); 如果我们在Activity中注册了BroadcastReceiver，当这个Activity销毁的时候要主动撤销注册否则会出现异常。 1234567@Overrideprotected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); //当Activity销毁的时候取消注册BroadcastReceiver unregisterReceiver(receiver);&#125; 4. BroadCastReceiver的生命周期BroadcastReceiver的生命周期，从对象调用它开始，到onReceiver方法执行完成之后结束。另外，每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完就销毁，如果BroadcastReceiver的onReceiver方法中不能在10秒内执行完成，Android会出现ANR异常。所以不要在BroadcastReceiver的onReceiver方法中执行耗时的操作。 5. 实例最新Android不再兼容静态注册，尽量用动态注册 先定义两个广播接收器 1234567891011121314151617public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //TODO String msg = intent.getStringExtra("msg"); Log.d("TAG", "接收的消息时： " + msg); setResultData("MyBroadcastReceiver接收到广播"); Toast.makeText(context, "时间： " + new SimpleDateFormat("yyyy-mm-dd hh.mm.ss").format(new Date()) + "\nMyBroadcastReceiver收到Action名为: " + intent.getAction().toString() + "的广播\nComponent: " + intent.getComponent() + "\nmsg: " + msg, Toast.LENGTH_LONG).show(); &#125;&#125; 12345678910111213public class SecondBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String msg=intent.getExtras().get("msg").toString(); String result=getResultData(); Toast.makeText(context,"时间："+new SimpleDateFormat("yyyy-MM-dd hh.mm.ss").format(new Date()) +"\nSecondBroadcastReceiver收到Action名为："+intent.getAction().toString() +"的广播 \nComponent:"+intent.getComponent() +"\nmsg:"+msg+"\n上一个接受者传来的reult:"+result, Toast.LENGTH_LONG).show(); &#125;&#125; 然后再在activity中发送广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class BroadcastDemoActivity extends AppCompatActivity &#123; Button general_BT, order_BT; MyBroadcastReceiver receiver; SecondBroadcastReceiver secondReceiver; private static final String ACTION = "com.android.broadcast.RECEIVER_ACTION"; private IntentFilter intentFilter; String TAG = "DEBUG"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast_demo); general_BT = (Button)findViewById(R.id.general_bc); order_BT = (Button)findViewById(R.id.order_bc); receiver=new MyBroadcastReceiver(); secondReceiver = new SecondBroadcastReceiver(); RegisterBroadcast(receiver,200); RegisterBroadcast(secondReceiver,100); general_BT.setOnClickListener(new Mylistener()); order_BT.setOnClickListener(new Mylistener()); &#125; private void RegisterBroadcast(BroadcastReceiver receiver, int Value)&#123; intentFilter = new IntentFilter(); intentFilter.addAction(ACTION); intentFilter.setPriority(Value); registerReceiver(receiver,intentFilter); &#125; class Mylistener implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id)&#123; case R.id.general_bc: Intent intent = new Intent("com.android.broadcast.RECEIVER_ACTION"); intent.putExtra("msg","我在发送广播！这智商一个普通的广播，" + "你们无法通过abortBroadcast()方法停止广播的传播， " + "也无法往Broadcast中存入数据因为他是异步的"); sendBroadcast(intent); Log.d(TAG, "发送成功啦！！！！"); break; case R.id.order_bc: Intent intent2 =new Intent(); intent2.setAction("com.android.broadcast.RECEIVER_ACTION"); intent2.putExtra("msg", "我在发送一个有序的广播，"+ "你们可以通过abortBroadcast()的方法停止广播的传播，"+ "也可以向Broadcast中存入数据"); sendOrderedBroadcast(intent2, null); break; default: break; &#125; &#125; &#125; @Override protected void onStop() &#123; super.onStop(); this.unregisterReceiver(receiver); this.unregisterReceiver(secondReceiver); &#125;&#125; 结果如下：]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程3-RecycleView以及其Adapter的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B3-RecycleView%E4%BB%A5%E5%8F%8A%E5%85%B6Adapter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. RecyclerView介绍 ListView的运行效率低 RecyclerView是增强版本的ListView 2. RecyclerView的三部曲2.1. 首先设置recyclerView的布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".RecycleDemoActivity"&gt; &lt;LinearLayout android:id="@+id/layout01" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/linearLayout_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="线性布局"/&gt; &lt;Button android:id="@+id/grid_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="网格布局"/&gt; &lt;Button android:id="@+id/staggeredLayout_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="瀑布布局"/&gt; &lt;/LinearLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/my_recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 2.2. 然后创建recyclerView的布局文件1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="100dp"&gt; &lt;TextView android:id="@+id/text_view" android:textSize="20dp" android:layout_width="wrap_content" android:text="6666" android:layout_marginTop="30dp" android:layout_gravity="center" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 2.3. 自定义RecyclerAdapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 需要重写// onCreateViewHolder(): 创建ViewHolder实例，并传入布局文件，返回这个实例// onBindViewHolder()：对RecyclerView子项的数据赋值，会在每个子项被滚动到屏幕内的时候执行，// 通过position参数得到当前项的Fruit实例，再讲数据设置到ViewHolder的TextView中// getItemCount(): 告诉RecyclerView一共有多少子项，直接返回数据源的长度public class RecycleAdapter extends RecyclerView.Adapter&lt;RecycleAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; mList; private Context context; // RecycleAdapter也有一个自己的构造函数 // 把要展示的内容传入 public RecycleAdapter(List&lt;String&gt; list, Context context)&#123; this.mList = list; this.context = context; &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; // 定义一个内部类MyViewHolder继承RecyclerView.ViewHolder // ViewHolder的构造函数要传入一个View参数，这个参数通常是RecyclerView子项的最外层布局， // 那么我们就可以通过findViewById()方法来获取布局中的TextView public class MyViewHolder extends RecyclerView.ViewHolder &#123; public TextView mView; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); mView = itemView.findViewById(R.id.text_view); &#125; &#125; //创建ViewHolder //onCreateViewHolder方法创建一个viewHolder，viewholder可以理解为一条数据的展示布局，这里我们自定义类LinearViewHolder创建一个只有TextView的item //这里我们需要创建每条布局使用的layout：recycle_item @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; return new MyViewHolder(LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.recycle_item, viewGroup, false)); &#125; //填充视图 //onBindViewHolder方法为item的UI绑定展示数据 @Override public void onBindViewHolder(@NonNull final MyViewHolder holder, final int position) &#123; holder.mView.setText(mList.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "点击子项"+position, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; public void addData(int position) &#123; mList.add(position, "Insert One"); notifyItemInserted(position); &#125; public void removeData(int position) &#123; mList.remove(position); notifyItemRemoved(position); &#125; public void clearALL()&#123; mList.clear(); notifyDataSetChanged(); &#125;&#125; 2.4. 在Activity中实现adapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class RecycleDemoActivity extends AppCompatActivity &#123; private Button linearBT, gridBT, starBT; private RecyclerView mRecyclerView; private RecycleAdapter mMyAdapter; private RecyclerView.LayoutManager mLayoutManager; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycle_demo); linearBT = (Button)findViewById(R.id.linearLayout_recycle); gridBT = (Button)findViewById(R.id.grid_recycle); starBT = (Button)findViewById(R.id.staggeredLayout_recycle); // RecyclerView的三部曲 01: 获取RecyclerView对象 mRecyclerView = (RecyclerView)findViewById(R.id.my_recycler_view); initData(); linearBT.setOnClickListener(new ButtonClicked()); gridBT.setOnClickListener(new ButtonClicked()); starBT.setOnClickListener(new ButtonClicked());// // 添加水平分割线// mRecyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)); &#125; private void initData() &#123; list = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; list.add("Item" + i); &#125; &#125; class ButtonClicked implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.linearLayout_recycle: mLayoutManager = new LinearLayoutManager(getApplicationContext()); break; case R.id.grid_recycle: mLayoutManager = new GridLayoutManager(getApplicationContext(),4); break; case R.id.staggeredLayout_recycle: //如果传入 StaggeredGridLayoutManager.VERTICAL则该布局支持纵向滑动，那么前面的 4 则指的是 4列。 //如果传入 StaggeredGridLayoutManager.HORIZONTAL，则该布局支持横向滑动，那么前面的4 则指的是 4行 mLayoutManager = new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL); break; default: mLayoutManager = new LinearLayoutManager(getApplicationContext()); break; &#125; //RecyclerView的三部曲 02：设置布局管理器 mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.addItemDecoration(new DividerItemDecoration(getApplicationContext(),DividerItemDecoration.VERTICAL)); // RecyclerView的三部曲 03： 添加适配器，适配器需要重写 mMyAdapter = new RecycleAdapter(list, getApplicationContext()); mRecyclerView.setAdapter(mMyAdapter); //设置Item增加、移除动画 mRecyclerView.setItemAnimator(new DefaultItemAnimator()); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: mMyAdapter.addData(1); break; case R.id.remove_item: mMyAdapter.removeData(1); break; &#125; return true; &#125;&#125; 3. 实现效果]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程2-ListView以及Adapter的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B2-ListView%E4%BB%A5%E5%8F%8AAdapter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. ListView的基本用法允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚出屏幕 布局文件中增加 ListView 定义一个实体类，用于设置需要保存的数据结构 源码中构造适配器 Adapter ，准备子项布局 通过id找到ListView的实例 ，准备数据结构 ListView设置适配器，派生ArrayAdapter 1.1. 增加ListView首先在Activity里面添加ListView插件，在布局文件中写入如下代码 12345678910111213&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".ListViewActivity"&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 1.2. 定义一个实体类，用于设置需要保存的数据结构定义一个实体类，作为ListView适配器的适配类型，新建类Fruit 1234567891011121314151617public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId)&#123; this.name = name; this.imageId = imageId; &#125; public int getImageId() &#123; return imageId; &#125; public String getName() &#123; return name; &#125;&#125; 1.3. 准备子项布局子项布局就是你需要在listview中每一行显示的格式，新建一个布局文件，写入如下数据 12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt; 1.4. 自定义适配器，继承ArrayAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; // 将上下文， listview子项布局的id和数据传入 public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects)&#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; // 每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前的Fruit实例 // 使用已经缓存好的view View view; ViewHolder viewHolder; if (convertView == null)&#123; // inflate出子项布局，实例化其中的图片控件和文本控件 // 加载传入的布局 // false： 只让我们在父布局中声明的layout属性升序，但是部位这个view添加父布局 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name); // 缓存图片控件和文本控件的实例 view.setTag(viewHolder); &#125; else&#123; view = convertView; // 取出缓存 viewHolder = (ViewHolder)view.getTag(); // 重新获取ViewHolder &#125; // 直接使用缓存中的图片控件和文本控件的实例 // 图片控件设置图片资源 viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; class ViewHolder&#123; // 这个类是为了避免每次载入lostview都需要findviewid的苦难 ImageView fruitImage; TextView fruitName; &#125;&#125; 1.5. 活动中应用自定义适配器123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ListViewActivity extends AppCompatActivity &#123; ListView lv01; ArrayList&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_list_view); initFruits(); FruitAdapter adapter = new FruitAdapter(ListViewActivity.this, R.layout.fruit_items, fruitList); lv01 = (ListView)findViewById(R.id.list_view); lv01.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cheery); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango); fruitList.add(mango); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程1-Activity详解]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B1-Activity%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. Activity简介 activity是一种可以保护用户界面的组件，用于和用户交互 一个应用程序可以有0个或者多个活动 一个活动伴随着一个布局文件 1.1.Activity的创建创建活动主要分为两步： 手动创建activity文件以及对应的布局文件,通过setContentView(R.layout.XXX)关联 在AndroidMnifest中注册生效 123456789&lt;application&gt;&lt;activity android: name = ".FirstActivity" android: label = "This is first Activity"&gt; &lt;intent-filter&gt; &lt;action android:name = "...MAIN"&gt; &lt;category android:name="...LAUNCHER"&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;/application&gt; 1.2.Activity中使用ToastToast是Android系统提供的一种非常好的提醒方法，通过一些短小的信息通知用户相关信息,创建Toast需要三个参数。第一个参数是Toaset要求的上下文，第二个是Toast显示的文本内容，第三个参数是它显示的时长 1Toast.makeText(FirstActivity.this, &quot;You are Ok!!!&quot;, Toast.LENGTH_SHORT).show() 1.3.Activity中使用Menu在Android中创建下拉菜单的几个步骤如下： 在res目录下新建menu文件夹，新建menu.xml文件 在文件中添加如下代码来创建下拉菜单 123456&lt;item android:id = "@+id/add_item" andrid:title:="Add"/&gt;&lt;item android:id = "@+id/remove_item" andrid:title:="Remove"/&gt; 主活动中重写onCreateOptionMenu()方法（通过Ctrl+O） 12345678public boolean onCreateOptionMenu(Menu menu)&#123; // 通过getMenuInfalter()方法得到MenuInfalter对象，调用inflate()方法来创建菜单 // 参数1： 指定那个资源文件来创建菜单 // 参数2： 指定我们的额菜单项将添加到那个menu对象中 getMenuInflater().inflate(R.meanu.main,menu); // 允许创建的菜单显示出来 return true;&#125; 为menu绑定监听器,重写onOptionsItemSelected()方法 123456789101112public boolean onOptionsItemSelected(MenuItem item)&#123; switch (item.getItemId())&#123; case R.id.add_item: Toast.makeText(this, "you clicked add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "you clicked remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125; 1.4. 使用Intent在活动之间穿梭Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还不可以在不同组件之间传递数据，Intent有两种形式显示Intent和隐示Intent,首先看显示Intent 显示Intent切换activity1Intent(Context packageContext, Class&lt;?&gt;cls) 从一个Activity跳到另外一个Activity的代码是 12Intent intent = new Intent(FirstActivity.this, SecondActivtiy.class);startActivity(intent); 隐示Intent切换activity隐示Intent不明确指明需要启动哪个活动，而知指定一系列更为抽象的action和category信息，然后交给系统去分析这个intent并找到合适的活动去启动(可以响应这个隐示Intent的活动) 在secondactivity的声明文件中写 123456&lt;activity android: name = ".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name = "...ACTION_START"&gt; &lt;category android:name="...category.DEFAULT"&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 上面的代码中指明了当前活动可以响应com.example.activitytest.ACTION_START这个action，而标签包含了一些附加信息，更加明确的指明了当前的活动能够响应的Intent中还可能带有的catogory，只有和中的内容同事匹配上Intent中指定的action和category时，才能够响应这个活动 修改FirstActiivty的代码为如下： 123Intent intent = new Intent("com.example.activitytest.ACTION_START");intent.addCategory("com.example.activitytest.DEFAULT")startActivity(intent) 这个方法一样可以切换activity 1.5. 通过Intent向下一个活动传递数据传数据 123456public void onClick(View v)&#123; String data = "hello from FirstActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intent.putExtra("extra_data", data); startActivity(intent);&#125; 取数据 123Intent intent = getIntent();String data = intent.getStringExtra("extra_data");Log.d("SecondActivity",data); 1.6. 返回数据给上一个活动 通过调用startActivtiyForResult()方法也是用于启动活动，但是这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 接收两个参数，第一个参数是Intent，第二个参数是请求吗，用于在之后的回调中判断数据的来源 传入数据 12345public void onClick(View v)&#123; String data = "hello from FirstActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivtiyForResult(intent, 1)&#125; 然后在第二个activity中添加返回数据的逻辑 1234Intent intent = new Intent();intent.putExtra("data_return", "hello first activity");setResult(RESULT_OK,intent);finish(); // 销毁的时候回回调上一个活动的onActivityResult()方法，因此我们需要重写那个方法来获得数据 1234567891011// 在firstActivity的onActivityResult()switch (requestCode)&#123; case 1: if (resultCode == RESULT_OK)&#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActviity", returnedData); &#125; break; default:&#125; 2. 活动的生命周期 2.1. 活动的状态 运行状态： 当活动处在返回栈的栈顶时 暂停状态： 当活动不再栈顶时，但仍然可见(屏幕对话框模式) 停止状态： 当活动不在栈顶，且完全不可见 销毁状态： 被内存回收 2.1. 活动的生存周期 周期 状态 说明 建议操作 onCreate() Created 第一次创建时调用，且只执行一次 活动的初始化操作，加载布局，绑定事件 onStart() Started 活动由不可见变为可见，完成得很快 app和用户交互，初始化组件 onResume() 运行状态 准备和用户交互时调用 当有异常时，进入暂停状态 onPause() 暂停状态 系统准备去启动或者恢复一个活动时调用 停止一些不想运行的操作(关闭camera),释放系统资源 onStop() 停止状态 活动完全不可见时调用 释放heavy任务，关闭CPU中的任务，保存到数据库 onDestroy() 销毁状态 活动销毁前调用 onRestart() 由停止状态变为运行状态 2.2. 保存活动的运行状态 通过onSaveInstanceState()方法保证在活动被回收之前一定会被调用，通过这个方法来解决活动被回收时临时数据得不到保存的问题 此方法会携带一个Bundle类型的参数，这个参数提供了一系列犯法来保存数据，putString(key,value),putInt(key,value) 保存数据 123456@overrideprotected void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); String tempData = "Something you just typed"; outState.putString("data_key", tempData)&#125; 恢复数据 ：在OnCreate()方法中取值就可以了 123456789@overrideprotected void onCreate(Bundle savedInstanceState)&#123; ....; if (savedInstanceState !=null)&#123; String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125;&#125; 3. 关于Activity的一些其他技巧3.1. 如何在任意activity中直接退出？如果目前你手机界面还在第三个activity中，你会发现当前退出程序很麻烦，需连续按3此Back键才行，按Home键至少把程序挂起，并没有退出程序 设置一个专门的集合类对所有的活动管理就行了 12345678910111213141516171819public class ActivityyCollector&#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity)&#123; activities.add(activity); &#125; public static void removeActivity(Activity activity)&#123; activities.remove(activity); &#125; public static void finishALL()&#123; for (Activity activity : activities)&#123; if (!activity.isFinishing())&#123; activity.finish(); &#125; &#125; &#125;&#125; 然后在活动中可用直接通过这个类来动态管理活动 123456789101112131415public class BaseActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); Log.d("BaseActivity",getClass().getSimpleName()); ActivityyCollector.addActivity(this); &#125; @Override protected void onDestroy()&#123; super.onDestroy(); ActivityyCollector.removeActivity(this); &#125; &#125;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
