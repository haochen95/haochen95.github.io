<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PhotoShop基本使用]]></title>
    <url>%2F2019%2F03%2F08%2FPhotoShop%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 图片格式 格式 说明 用途 psd photoshop的专用格式，这种格式是不压缩的，保留了突出，透明和半透明信息 保存图片原始数据，方便图片修改 jpg 有损压缩，压缩效率高，容量小，网络传输快,不可保存为透明背景 不需要透明背景的时候使用 gif 无损压缩格式，最多有256种颜色，颜色丰富的图片转化为这种格式会颜色失真，它的背景也可以是透明，有锯齿 也可以制作动态 png 代替gif，无损压缩，背景可以是透明和半透明，没有锯齿 用于firework处理图片的 webp 压缩方面比jpg更加优秀，在质量相同的情况下，webp格式的体积比jpg小40% 只在Chrome上面支持 位图和矢量图 由一个个的方形的像素点排列在一起拼接，位图放大时，图像会失真，上面的5种都是位图矢量图是由函数曲线组成的，无图像块 svg 矢量二维图格式，即使放大也不会有方块出现或者失真 但是颜色不丰富 flash 矢量动画文本格式 现在少用了 总结 如果使用不透明背景的图片，用jpg 如果使用透明或者半透明的图片,用png 制作网页图标时候，如果图标有多种颜色，用gif/png，如果图片是单色的用svg，如果图标是动画的用gif 2. PS的基本操作2.1. 工具栏介绍选择图层 点击移动工具 按住Ctrl键选择某个图层 图像放缩平移 缩放工具： 按住alt点击缩小，快捷键ctrl + +/-来控制放大缩小，双击缩放工具图标恢复到原来的大小 平移工具： 对图像进行平移，如果在使用其他工具的前提下，直接按住空格即可实现平移 移动选择和图像 按住Ctrl，在图像上面点击可以选中图层 选择移动工具，勾选工具属性栏上的自动选择图层，可以在图像上点击选中的图层 如果操作失误，可以通过历史记录回到之前的状态 一般不建议自动选择，取消后，按住Ctrl键就可以选择某个选中的图层 移动元素同时按住alt键可以复制移动一个图层 图层面板的操作，包括图层的显示隐藏，图层顺序，新建图层，图层删除等 针对图像中选择图层的操作 移动 自由变换(Ctrl + T)(Shift等比例放缩)，执行菜单命令， 编辑 拖拽到另外一张图片上面完成图层拷贝 选框工具 有三种样式： 矩形，椭圆形，单行，单列 有三种选区模式：新选区，添加选区，从选区减去，选区叠加 可通过Ctrl+D取消选区 套索工具 套索工具 自己画出来的选区，其他操作跟选框工具一样 多边形套索工具 通过多边形线段连接来构建选区(delete键删错错误操作) 磁性套索工具 顺着轮廓移动，自动产生 魔棒和快速选择工具 在需要选择的区域内部点击 配合添加选区使用 魔棒工具跟上面的功能类似，但是需要调整容差和连续性 魔棒+反选：最强大 * 针对选区的操作 复制 粘贴 填充(编辑-&gt;填充) 描边（编辑-描边）：对边框设置 删除-delete键 自由变化Ctrl+T(可以改变选区的大小) 擦除和污点 修改错误 文本输入 选择T工具 再选择工具-》放在需要修改的文本上-》修改文本 参考线 先打开：视图-》标尺 然后打开：视图-》新建参考线-》输入位置建立水平/垂直的参考线 图像大小 点击：图像-》图像大小：查看图像的尺寸大小 尺寸测量 切片工具： 双击切片弹出切片对话框 切片选择工具 矩形框工具 裁剪图像 对选区执行图像裁切 2.2. 批量切图在一张效果图中，同时切多个图 使用切片工具 先切一个，切完一个，双击后命名保存 一定要把背景藏起来后(图层)，然后再保存 文件-&gt;存储为web存储格式-&gt;选择PNG-24 2.3. 雪碧图将一些小图标合并成一个图，发送HTTP请求，用于优化网页加载 ，适用于装饰性图片，比如说图标，箭头等 新建一个大致高宽的图，背景为透明 根据使用的顺序，从文件夹拖入到创建的图中(上下顺序) 创建50px等高的参考线 将每个图片放在左上角 然后只选择图片区域，图像-&gt;裁剪-&gt;保存为PNG-24格式 3.前端开发流程 创建项目目录 创建image, css, js文件夹 使用PhotoShop对效果图进行切图，切出网页制作中需要的小图片 将装饰类图像合并，制作成雪碧图 结合PhotoShop和代码编辑器，参照效果图，进行HTML和CSS代码书写，制作页面]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实例演示]]></title>
    <url>%2F2019%2F03%2F07%2FCSS%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[1. 上下页12345678910111213141516171819202122232425262728293031323334353637@charset "UTF-8";.pagenation&#123; width: 958px; height: 40px; border: 1px solid #000; margin: 50px auto; font-size: 0; /* 水平居中 */ text-align: center;&#125;.pagenation a&#123; /* 直接给a背景色，是做不到，必须转化为行内块 */ display: inline-block; /* 上下是5，左右是10 */ padding: 5px 10px; background-color: gold; font-size: 12px; font-family: 'Microsoft Yahei'; /* 去除下划线 */ text-decoration: none; margin: 8px 5px; color: #333;&#125;/* 选中的时候显示的样式 */.pagenation a:hover&#123; background-color: red; color:#fff;&#125;.pagenation span&#123; display: inline-block; font-size: 12px;&#125; 12345678910111213&lt;div class="pagenation"&gt; &lt;a href=""&gt;上一页&lt;/a&gt; &lt;a href=""&gt;1&lt;/a&gt; &lt;a href=""&gt;2&lt;/a&gt; &lt;a href=""&gt;3&lt;/a&gt; &lt;a href=""&gt;4&lt;/a&gt; &lt;span&gt;...&lt;/span&gt; &lt;a href=""&gt;17&lt;/a&gt; &lt;a href=""&gt;18&lt;/a&gt; &lt;a href=""&gt;19&lt;/a&gt; &lt;a href=""&gt;20&lt;/a&gt; &lt;a href=""&gt;下一页&lt;/a&gt;&lt;/div&gt; 2. 导航页123456789101112131415&lt;ul class="menu"&gt; &lt;li&gt;&lt;a href="#"&gt;首 页&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="line"&gt;|&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;网站建设&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930313233.menu&#123; width: 958px; height: 40px; border: 1px solid #000; margin: 50px auto; padding: 0; /* 不要列表的点 */ list-style: none; text-align: center; /* 设置行内块元素的高度 */ line-height: 40px; font-size: 0;&#125;.menu li&#123; display: inline-block; font-size: 14px;&#125;.menu li a&#123; font-family: 'Microsoft Yahei'; color: #333; text-decoration: none;&#125;.menu li a:hover&#123; color: red;&#125;.menu .line&#123; color: #333; margin: 0 20px;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程08-全部语法总结]]></title>
    <url>%2F2019%2F03%2F07%2FCSS%E6%95%99%E7%A8%8B08-%E5%85%A8%E9%83%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] 1. CSS基本语法1.1. CSS基本定义CSS的定义方法时： 1234选择器&#123; 属性： 值； 属性： 值；&#125; CSS引入页面的方法 在HTML中通过外联方法 1&lt;link rel = "stylesheet" type="text/css" href="css/style.css"&gt; 内联式，通过标签的style属性，直接在标签上写样式 1&lt;div style="width: 100px; height: 100px"&gt;..&lt;/div&gt; 1.2. CSS文本设置常用的应用文本的css样式| 属性 | 说明 | 值 || —————– | —————— | ——————————— || color | 文本颜色 | 颜色值 || font-size | 文字大小 | px值 || font-family | 文字字体 | 字体名称 || font-style | 字体是否倾斜 | normal:不倾斜italic：倾斜 || font-weight | 字体是否加粗 | normal:不加粗 bold:加粗 || font | 同时设置上面的属性 | 加粗 字号 /行高 字体 || line-height | 文字的行高 | px值 || text-decoration | 文字的下划线 | none去除下划线 || text-indent | 文字的首行缩进 | 首行缩进24px || text-align | 文字的水平对齐方式 | center字体居中 | 2.CSS选择器2.1. 标签选择器 直接通过html中的标签名字来选择对于的元素 选择面太广，很少用 1234/* 直接选择html中所有的div元素 */div&#123; color: red;&#125; 2.2. id选择器 在html中设置一个id，在css中引用设置它 id只能是一个全局唯一样式 一次只能选择一个元素 很少用 123#box&#123; color: pink;&#125; 1&lt;div id="box"&gt;666&lt;/div&gt; 2.3. 类选择器 为了补偿id选择器的缺点，可以一下子设置多个元素样式 1234567.lei&#123; color: red;&#125;.indent&#123; text-indent: 20px;&#125; 12345&lt;div class="lei indent"&gt;1&lt;/div&gt;&lt;div id = "box" class="lei"&gt;2&lt;/div&gt;&lt;div class="lei"&gt;3&lt;/div&gt;&lt;div class="lei"&gt;4&lt;/div&gt;&lt;div class="lei"&gt;5&lt;/div&gt; 2.4. 层级选择器 主要用于选择父元素下的子元素，或者子元素下面的子元素，可与标签元素结合使用 12345678910.list&#123; height: 30px;&#125;/* 这是一个两层的层级选择器 */.list a&#123; text-decoration: none; color: #333;&#125; 123456&lt;ul class="list"&gt; &lt;li&gt;&lt;a href = ""&gt;新闻标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = ""&gt;新闻标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = ""&gt;新闻标题&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href = ""&gt;新闻标题&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 2.5.组选择器 多个选择器，有相同的样式设置，可使用组合选择器 12345678910111213141516171819202122232425/* 设置3个类的公共属性 */.box1,.box2,.box3&#123; font-size: 14px; text-indent: 28px;&#125;/* 然后在使用类选择器个性化 */.box1&#123; color: red;&#125;.box2&#123; color: green;&#125;.box3&#123; color: orange;&#125;/* 更多设置形式 *//* 匹配所有的p,b,i,span元素 */p,b,i,span &#123; color: green;&#125; 123&lt;div class="box1"&gt;3&lt;/div&gt;&lt;div class="box2"&gt;4&lt;/div&gt;&lt;div class="box3"&gt;5&lt;/div&gt; 2.6. 伪类和伪元素选择器 常用的伪类选择器为hover，表示鼠标悬停在元素上时的状态 1234/* 鼠标放到list类下的a时，会变色 */.list a:hover&#123; color: gold;&#125; 伪元素选择器有before和after，它们可通过样式在元素中插入内容 12345678910111213141516171819202122/* 块级首行 *//* 在p,div，body等块级元素才有效果 */::first-line&#123; color: red;&#125;/* 块级首字母 */::first-letter&#123; color: red;&#125;/* 文本前插入内容 *//* 变成：点击百度 */a::before&#123; content: '点击-';&#125;/* 文本后插入内容 *//* 百度搜索 */a::after&#123; content: '搜索';&#125; 3.CSS表格123456789101112131415161718192021222324252627282930313233.goods&#123; /* 通用属性 */ width: 300px; height: 300px; text-align: center; /* 设置的单元格相邻边是否被合并 separate: 单元格边框独立，默认 collapse： 边框合并（变成实心的实现） */ border-collapse: collapse; /* 设置单元格边框边距，只有在border-collapse为separate情况下才有用 */ border-spacing: 10px; /* 标题方位 top, bottom */ caption-side: top; /* 空内容单元格的是否显示,hide */ empty-cells: hide; /* 表格的排版方式 auto: 内容过长的时候，会拉伸整个单元格，挤压其他单元格 fixed： 内容过长时，不会拉伸，会换行处理 */ table-layout: fixed;&#125;/* 设置表头的背景颜色 */.goods th&#123; background-color: green; color: #ffffff;&#125; 123456789101112131415161718192021222324&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;table class = "goods" border="1"&gt; &lt;caption&gt;人员表格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;34&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;43&lt;/td&gt; &lt;/tr&gt; 4.盒模型4.1. 什么是盒子模型元素在页面中显示成一个方块，类似一个盒子，CSS盒子模型就是显示盒子的比喻，帮组我们设置元素对应的样式 盒子的边框： border 盒子内的内容和边框的间距： padding 盒子和盒子之间的间距： margin 4.2设置边框 border：长度值或者百分比 border-top/bottom border-left/right 12345678910111213141516.box&#123; width: 200px; height: 100px; background-color: red; /* 设置顶部边框的宽度，颜色 */ /* border-top-width: 10px; border-top-color: #000; */ /* 设置线的样式，实线solid， 虚线dashed， 点线dotted */ /* border-top-style: solid; */ /* 全部一下子来写 */ /* border-top: 10px solid #000; */ border: 10px solid orange;&#125; 1&lt;div class="box"&gt;&lt;/div&gt; 4.3. 盒子内边距 padding：长度值或者百分比 padding-top/bottom padding-left/right 123456.box&#123; padding: 20px; /* 上，右，下，左 */ /* padding: 10px 20px, 10px, 20px; */&#125; 4.4. 盒子外边距根据body文档的左上角为起点 margin margin-top/bottom margin-left/right 注意 当两个垂直外边距相遇时，它们将形成一个新的外边距，这个新的外边距长度等于两个发生合并的外边距的高度中的最大值，解决方法是 只设置margin-top,不设置margin-bottom 将元素浮动或者定位 盒子水平居中方法 :使用auto平分水平距离 123.box&#123; margin: 100px auto;&#125; 4.5. 盒子尺寸大小盒子宽度 = width + 左右padding值 + 左右的border值盒子高度 = height + 上下的padding值+ 上下的border值 1234567891011121314.box1,.box2,.box3&#123; width: 50px; height: 50px; background-color: gold; margin: 20px;&#125;.box2,.box3&#123; border: 50px solid #000;&#125;.box3&#123; padding: 50px;&#125; 123&lt;div class="box1"&gt;1&lt;/div&gt;&lt;div class="box2"&gt;2&lt;/div&gt;&lt;div class="box3"&gt;3&lt;/div&gt; 如何解决盒子尺寸动态变化的问题？ 使用indent 文本垂直居中line-height 文本水平居中text-align 盒子水平居中margin: 10px auto; 假设设置一个高宽45*400px的盒子 1234567891011.box2&#123; width: 400px; height: 50px; border-top: 1px solid #f00; border-bottom: 3px solid #666; font-size: 20px; font-family: "Microsoft Yahei"; text-indent: 15px; /* 让文字居中 */ line-height: 50px;&#125; 4.6. 盒子元素溢出4.6.1. margin-top塌陷在两个盒子嵌套的时候，内部的盒子设置的margin-top会加到外部的盒子上，导致内部的盒子margin-top设置失败，解决方法如下： 外部盒子设置一个边框 外部盒子设置overflow: hidden 使用伪元素类(常用) 12345/* 类似于加边框 */.clearfix:before&#123; content: ""; display: table;&#125; 4.6.2. 元素溢出当子元素的尺寸超出父元素的尺寸时， 需要设置父元素显示溢出的子元素的方式，设置的方法通过overflow属性设置 属性值 说明 visible 内容不会被修剪，会呈现在元素框外部，默认 hidden 内容会被修剪，并且其他内容不可见，此属性还有清除浮动、清除margin-top塌陷的功能 scroll 内容会被修剪，通过滚动条显示 auto 如果内容被修剪，就通过滚动条显示 inherit 规定应该从父元素继承overflow属性的值 什么是溢出 12345&lt;div class="con"&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.con&#123; width: 500px; height: 300px; border: 1px solid #333; margin: 50px auto;&#125;.box&#123; width: 400px; height: 600px; background-color: gold;&#125; 以下这个图就是溢出 设置溢出方法 1234567.con&#123; width: 500px; height: 300px; border: 1px solid #333; margin: 50px auto; overflow: scroll;&#125; 5. 块元素、内联元素、内联块元素元素就是标签，布局中常用的三种标签: 块元素，内联元素，内联块元素 5.1. 块元素块元素，也称为行元素，布局中常用的标签div,p,ul,li,h1-h6,dl,dt,dd等都是块元素，它的行为特点是 支持全部的样式 如果没有设置宽度，默认宽度为父级宽度100% 水平居中text-algin 盒子占据一行，即使设置了宽度 块元素相对于父元素水平居中margin: 0 auto; 5.2. 内联元素也称为行内元素，布局中常用的a,span,em,b,strong,i等等都是内联元素，它们在布局中的行为： 支持部分样式(不支持宽、高、margin上下，padding上下) 宽高由内容决定 盒子并列显示 代码换行，盒子之间会产生间距 子元素是内联元素，父元素可以通过text-algin属性设置子元素水平对齐，line-height=整体高度设置垂直对齐 解决内联元素间隙的方法 去掉内联元素之间的换行(不建议) 将内联元素的父级设置font-size为0，内联元素自身再设置font-size 1234567.con&#123; font-size: 0;&#125;.con a&#123; font-size: 20px;&#125; 5.3. 内联块元素也称为行内块元素，结合块元素和内联元素的优点，ima,input属于这一块，我们可以通过display属性将块元素或者内联元素转换成内联块元素，它们在布局中表现的行为： 支持全部样式 如果没有设置宽高，宽高由内容决定 盒子并在一行 代码换行，盒子之间会产生间距 子元素是内联元素，父元素可以通过text-algin属性设置子元素水平对齐，line-height=整体高度设置垂直对齐(解决方案和内联元素的一样) display属性 属性 说明 none 元素隐藏不显示，且不占位置 block 元素以块元素显示 inline 元素以内联元素显示 inline-block 元素以内联块元素显示 1234.con&#123; /* 将div块标签转化为内联块元素 */ display: inline-block;&#125; 6.CSS浮动文档流 文档流，是指按照html标签编写的顺序一次从上到下，从左到右排列，块元素占一行，行内元素在一行只能从左到右排列，先写的先排，后写的后排，每个盒子都占据自己的位置 6.1. 浮动的特性 浮动元素有左浮动(float:left)和右浮动(float:right) 浮动的元素会向左或者向右浮动，直到碰到了父元素边界，浮动元素，或者未浮动元素才会停下来 相邻浮动的块元素可以并在一行，超出父级宽度就换行 浮动会让行内元素或者块元素自动转为行内块元素 浮动元素后面没有浮动的元素会占据浮动元素的位置，没有浮动的元素内的文字会避开浮动的元素，形成文字饶图的效果–也就是说浮动元素像是浮起来一样，后面的元素就占据了浮动起来空的位置，但是其中的文字会避开浮动的元素 父元素内整体浮动的元素无法撑开父类，需要清除浮动 浮动元素之间没有垂直margin的合并 浮动特性1-5 1234567891011121314/* 碰到父元素边界停下 */.box1&#123; float: left;&#125;/* 碰到父元素边界停下 */.box2&#123; float: right;&#125;/* 碰到box1浮动元素边界停下 */.box3&#123; float: left;&#125; 6.2. 清除浮动 父级上增加属性overflow: hidden（在定位的时候会有问题 ） 在最后一个子元素的后面加入空的div，给它样式属性clear: both(不推荐) 使用成熟的清浮动样式类(推荐) 12345678910111213/* 既可以清除margin-top的bug，也可以清除浮动 */.clearfix:after, .clearfix:before&#123; content: ""; display: table;&#125;.clearfix:after&#123; clear: both;&#125;.clearfix&#123; zoom: 1;&#125; 清除浮动的用法(在父级上添加) 12&lt;div class = "con clearfix"&gt; 7. 定位7.1. 定位简介可以使用CSS的position属性来设置元素的定位类型，position的设置项如下： relative： 相对定位元素，元素所占的文档流位置不变，元素本身相对文档流进行位置偏移 absolute： 绝对定位元素，元素脱离文档流，不占据文档流的位置，可以理解为漂浮在文档流的上方，相对于上一个设置了相对或者绝对或者固定定位的父级元素来进行定位，如果找不到，就相当于body元素定位 fixed： 固定定位元素，元素脱离文档流，不占据文档流的位置，可以理解为为漂浮在文档流的上方，当有滚动条的时候，元素会跟随滚动条一直显示 static: 默认值，没有定位，元素出现在正常的文档流中，相当于取消定位属性或者不设置定位属性 inherit: 从父元素继承position的值 7.1.1. 相对定位123456789101112131415161718192021222324.con&#123; width: 400px; height: 400px; border: 1px solid #000; margin: 100px auto 0;&#125;.con div&#123; width: 200px; height: 100px; margin: 20px; background-color: gold; font-size: 40px; text-align: center; line-height: 100px;&#125;.box01&#123; position: relative; top: 80px; left: 50px; background-color: green;&#125; 7.1.2. 绝对定位123456.box01&#123; position: absolute; top: 50px; left: 50px; background-color: green;&#125; 我们也可把外部容器设置为定位的起点 1234567891011121314.con&#123; width: 400px; height: 400px; border: 1px solid #000; margin: 100px auto 0; position: relative;&#125;.box01&#123; position: absolute; top: 50px; left: 50px; background-color: green;&#125; 7.1.3. 固定定位123456.box01&#123; position: fixed; top: 50px; left: 50px; background-color: green;&#125; 7.2. 定位元素的特性绝对定位和固定定位的宽元素和行内元素会自动转化为行内块元素 7.3. 定位元素层级定位元素是浮动的正常的文档流之上的，可以用z-index属性来设置元素的层级 7.4. 典型的 定位布局 固定在顶部的菜单 水平垂直居中的弹框 固定的侧边的工具栏 固定在底部的按钮 7.5. 浮动定位的范例1. 导航栏12345678910&lt;ul class="menu"&gt; &lt;li class="active"&gt;&lt;a href=""&gt;首 页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li class="new"&gt;&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445.menu&#123; width: 950px; height: 40px; margin: 50px auto 0; list-style: none; background-color: #55a8ea; padding: 0; position: relative;&#125;.menu li&#123; float: left; width: 100px; height: 40px; text-align: center; line-height: 40px;&#125;.menu li a&#123; font-size: 14px; font-family: 'Microsoft Yahei'; color: #fff; text-decoration: none;&#125;.menu .active&#123; background-color: #00619f;&#125;.menu li:hover&#123; background-color: #00619f;&#125;.menu .new&#123; width: 30px; height: 30px; background: url(new.png) no-repeat; position: absolute; left: 433px; top: -20px;&#125;.menu .new:hover&#123; background: url(new.png) no-repeat;&#125; 2. 新闻列表123456789101112&lt;div class="news_list_con"&gt; &lt;h3&gt;&lt;span&gt;新闻标题&lt;/span&gt;&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;特征布局：新闻列表所需要的至少&lt;/a&gt;&lt;span&gt;2016-12-25&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.news_list_con&#123; width: 600px; height: 290px; border: 1px solid #ddd; margin: 50px auto 0; overflow: hidden;&#125;.news_list_con h3&#123; height: 50px; width: 560px; border-bottom: 1px solid #ddd; margin: 0px auto;&#125;.news_list_con h3 span&#123; display: inline-block; height: 50px; border-bottom: 2px solid red; font-size: 18px; line-height: 50px; font-family: 'Microsoft Yahei'; padding: 0 15px;&#125;.news_list_con ul&#123; list-style: none; padding: 0; width: 560px; height: 238px; margin: 7px auto 0;&#125;.news_list_con ul li&#123; height: 38px; border-bottom: 1px solid #ddd;&#125;.news_list_con ul a&#123; float: left; height: 38px; line-height: 38px; font-size: 14px; font-family: 'Microsoft Yahei'; text-decoration: none; color: #000;&#125;.news_list_con ul a:before&#123; content: ".";&#125;.news_list_con ul a:hover&#123; color: red;&#125;.news_list_con ul span&#123; float: right; height: 38px; line-height: 38px; font-size: 14px; font-family: 'Microsoft Yahei'; color: #000;&#125; 8. CSS背景页面上放图片的方法 方法 说明 直接通过src 占用空间 通过backgound-image 图片不占用空间，只是作为背景，可以在上面写字.. backgound-image属性解释 background是CSS中很重要的一个属性，它复制给盒子设置背景图片和背景颜色的，background是一个复合属性，他可以分解成如下几个设置项 backgound-color： 设置背景颜色 image postion color repeat backgound-image： 设置背景图片地址 backgound-repeat： 设置背景图片如何重复平铺 repeat(default),repeat-X,repeat-Y, no-repeat backgound-position： 设置背景图片位置 水平(left/right/center) 垂直(top/bottom/center)同时设置:必须在no-repeat情况下使用 水平偏移(10px) 垂直偏移(0px)：参考点是 父元素的左上角 backgound-attachment： 设置背景图片是固定还是随着页面滚动条滚动 fixed：不随着滚动 123456.box&#123; width: 200px; height: 200px; border: 1px solid red; background-image: url(news.png);&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程07-传统布局和多列布局]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B07-%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80%E5%92%8C%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[[TOC] 1.CSS传统布局1.1. 布局的类别1.1.1. 表格布局表格布局就是通过设定固定的单元格，去除表格边框和填充实现的额布局，当然这个布局不建议使用，表示应当用于二维表的使用 1.1.2. 浮动布局:最流行的1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="style.css"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; header &lt;/header&gt; &lt;aside&gt; aside &lt;/aside&gt; &lt;section&gt; section &lt;/section&gt; &lt;footer&gt; footer &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334@charset "UTF-8";body&#123; /* auto的作用是居中 */ margin: 0 auto; border: 1px solid red; width:960px;&#125;header&#123; height: 120px; background-color: olive;&#125;aside&#123; width: 200px; height: 500px; background-color: purple; float: left;&#125;section&#123; width: 760px; height: 500px; background-color: maroon; float: left;&#125;footer&#123; height: 120px; background-color: grey; /* 清理浮动 */ clear: both;&#125; 1.1.3. 定位布局在使用定位布局之前，我们需要先了解一下定位属性的用法，CSS提供了position属性来实现元素的绝对定位和相对定位 属性 说明 static 默认值，无定位 absolute 绝对定位，top,right,bottom,left进行位移 relative 相对定位, top,right,bottom, left进行位移 fixed 以窗口参考定位,top,right,bottom, left进行位移 绝对定位 绝对定位，脱离文档流(好像浮在了空中一般，后面的元素就会跑到这个元素的下面)，以文档左上角0,0为起点 在文档的左上角，拖动滚动条的时候会消失 绝对定位长度，高度一定要指明 1234567891011121314151617header&#123; /* 绝对定位 */ position: absolute; /* 参考点在窗口左上角 */ top: 0; left:0; /* 设置层次度，数字越大，越高，这在多个元素重叠的时候才有用 */ z-index: 1; &#125;/* aside会在header上面 */aside&#123; position: absolute; top: 20px; left: 20px; z-index: 2&#125; 窗口参考定位 拖动滚动条的时候，也会一直显示 123456header&#123; /* 窗口定位 */ position: fixed; top: 0; left: 0;&#125; 相对定位 不脱离文档流，占位偏移 以自己原来位置为基准点进行偏移 12345header&#123; position: relative; top: 100px; left: 100px;&#125; 通过定位布局来写框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@charset "UTF-8";body&#123; width: 960px; margin: 0 auto; position: relative;&#125;header&#123; width: 960px; height: 120px; background-color: olive; position: absolute;&#125;aside&#123; width: 200px; height: 500px; background-color: purple; /* 为每个组件加入边框的时候,不算入总长度用box-sizing */ border: 5px solid green; padding: 15px; box-sizing: border-box; position: absolute; top: 120px; left: 0;&#125;section&#123; width: 760px; height: 500px; background-color: maroon; border: 5px solid orange; padding: 20px; box-sizing: border-box; position: absolute; top: 120px; right: 0;&#125;footer&#123; width: 960px; height: 120px; background-color: gray; position: absolute; top: 620px; left: 0;&#125; 2. 多列布局做成像一个报纸一样的布局，如果一列的内容过多，会自动添加到前一列 2.1. column属性 属性 说明 columns 集成column-width和column-count两个属性 column-width 定义每列宽度 column-count 定义分列列数 column-gap 定义列间距 column-rule 定义列边框,分割线 column-span 定义多列布局中子元素跨列效果 column-fill 控制每列的列高效果 1234567891011121314151617div&#123; /* 分为3列显示，并且自适应内容 */ /* columns: auto 3; */ /* 当每列内容小于150px的时候，就会自动剪掉一列，变成2列显示 */ columns: 150px 3; column-gap: 50px; column-rule: 2px dashed gray;&#125;h1&#123; /* 横跨所有列 */ text-align: center; column-span: all;&#125; 12345678910111213141516&lt;div&gt; &lt;h1&gt;科技新闻&lt;/h1&gt; &lt;h3&gt;第一段内容&lt;/h3&gt; &lt;p&gt;不久前的2月26日晚，高雄市政府发布新闻稿，正式公布韩国瑜上任后成立的“高雄市政府两岸小组”27名成员名单。在高雄市政府公布的两岸小组名单中，既有来自高雄市政府的政府官员，也有来自大学的知名学者和企业家，包括四名来自大陆台商协会的会长，深圳台商协会会长陈忠和、广州台商协会会长王庆祥、厦门台商协会会长吴家莹、上海台商协会会长李政宏等人名列其中。&lt;/p&gt; &lt;h3&gt;第二段内容&lt;/h3&gt; &lt;p&gt;另外，国台办发言人安峰山3月4日应询表示，高雄市长韩国瑜拟于3月22日至28日率高雄市参访团到香港、澳门、深圳、厦门等地参访，开展交流合作。我们欢迎并支持在坚持“九二共识”基础上开展两岸城市交流合作，共同增进两岸同胞利益福祉。&lt;/p&gt; &lt;h3&gt;第三段内容&lt;/h3&gt; &lt;p&gt;在这种情况下，美国自然想敲打一下印度。此次美国政府放出取消印度零关税待遇的时机耐人寻味。美国贸易代表处称，最快将在政府通知国会和两国政府60天后实施，而60天后的5月恰逢印度举行选举。莫迪政府力推电子商务新规的本意是为了在选前安抚国内中小企业的不满情绪，并旨在为大选做足准备。美国选择这个时机敲打印度，无疑对莫迪政府形成不小的压力。（海外网评论员 戴尚昀）&lt;/p&gt; &lt;h3&gt;第四段内容&lt;/h3&gt; &lt;p&gt;美印关系的微妙变化不仅体现在经贸领域。面对美国对伊朗实施的制裁，印度绕开美元，直接以卢比购买伊朗原油；美国介入委内瑞拉政局，切断对美石油出口后，印度在2月上半月成为委石油最大买家；莫迪政府不顾美国反对，坚持购买俄罗斯S-400防空导弹……莫迪政府这一系列悖逆“美国意愿”的举动，加深了美印关系的“貌合神离”。&lt;/p&gt; &lt;h3&gt;第五段内容&lt;/h3&gt; &lt;p&gt;据路透社报道，美国总统特朗普当地时间3月4日致函美国国会，称有意结束在普遍优惠关税计划（普惠关税）下对印度和的贸易优惠待遇。一旦美国国会批准，就意味着印度向美国出口的56亿美元商品的零关税待遇将被取消&lt;/p&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程06-高级属性]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B06-%E9%AB%98%E7%BA%A7%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 渐变效果1.1 线性渐变CSS3提供了linear-gradient(方位,开始颜色,结束颜色)属性实现背景颜色的渐变功能，在background-image设置。属性如下 属性 说明 方位 渐变的方位，可用值是to top, to top right, to right, to bottom to bottom left, to left, to top left 开始的颜色 颜色值 结束的颜色 颜色值 12345678910111213141516171819div&#123; width:500px; height:500px; background-image: linear-gradient(to top left, orange, green); /* 可用自定义角度 */ background-image: linear-gradient(45deg, orange, green); /* 可用使用多个颜色 */ background-image: linear-gradient(45deg, orange, green, blue,red); /* 使用透明渐变来增加层次感 */ background-color: red; background-image: linear-gradient(to top right, rgba(0,0,0,0.6),rgba(0,0,0,0)); /* 重复渐变的效果 */ background-image: repeating-linear-gradient(orange 10px, green 30px);&#125; 1.2. 放射性渐变通过radial-gradient属性设置，其参数跟之前的一样 123456789101112131415div&#123; width:500px; height:500px; /* 圆形放射 */ background-image: radial-gradient(circle, orange, green); /* 调整圆心到顶部 */ background-image: radial-gradient(circle at top, orange, green); /* 调整圆心到右顶 */ background-image: radial-gradient(circle at top right, orange, green); /* 调整圆的半径 */ background-image: radial-gradient(circle closest-side, orange, green); /* 重复渐变的效果 */ background-image: repeating-radial-gradient(circle 50px, orange, green);&#125; 2. CSS边框图片的效果CSS3提供了一个新的属性集合，用这几个属性可以嵌入图片形式的边框，这样，边框就可以自定义了 border-image-source：引入背景图片地址 border-image-slice： 切割引入背景图片 border-image-width： 边框图片的宽度 border-image-repeat： 边框背景图片的排列方式 border-image-outset： 边框背景向外扩张 border-image: 上面5个的简写 3. CSS变形效果对元素进行缩放，平移和选装 3.1. transformCSS3提供了元素变形的效果，也叫作变换，它可以将元素实现选装，缩放和平移的功能，属性有两个transform（指定应用的变换功能）和transform-origin（指定变换的起点） transform的属性值 属性值 说明 none translate(长度值或百分数值)translateX(长度值或百分数值)translateY(长度值或百分数值) 在水平，垂直或者两个方向平移 scale(value),scaleX(value),scaleY(value) 在水平，垂直或者两个方向缩放 rotate(angle) 旋转元素 skew(angle),skewX(angle),skewY(angle) 在水平，垂直或者两个方向倾斜 matrix(4-6数值，逗号隔开) 指定自定义变换 1234567891011121314151617181920212223body&#123; margin: 100px;&#125;div&#123; width: 200px; height:200px; background-color: green; box-shadow: 2px 2px 2px gray; /* 平移：向左边，下边移动 */ transform: translate(200px,200px); /* 缩放 */ transform: scale(1.5,0.5); /* 旋转 */ transform: rotate(45deg); /* 向内部倾斜 */ transform: skew(45deg); &#125; 3.2.transform-origin设置变换的基准参考点，默认是在元素的中心位置，如果改变了基准点，就会按照这个基准进行变形 3.3. 3D立体变形由于3D是立体三维，有x,y,z三个轴，以下是3D变形的属性值表 属性值 说明 translate3d(x,y,z) 3D方式平移元素 translateZ(z) 3D方式平移元素的Z轴 scale3d(x,y,z) 3D方式缩放一个元素 scaleZ(z) 设置3D方式缩放元素的z轴 rotate3d(x,y,z,a) 3D方式选择元素 3.3.1. transform-style指定嵌套元素在3D空间的显示，一般设置到当前元素的父元素 flat： 默认值，所有子元素在2D平面呈现 preserve-3d： 子元素在3D平面显示 1transform-style: preserve-3d; 3.3.2. perspectiveperspective是3D变形的重要属性，用于设置查者的位置，并将可视内容映射到一个视锥上，继而投放到一个2D平面上 属性值 说明 none 默认值，表示无限角度来看3D物体，但是看上去是平的 长度值 接受一个长度单位大于0的值，值越大，角度越远]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程05-表格列表以及其他样式设置]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B05-%E8%A1%A8%E6%A0%BC%E5%88%97%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 表格样式12345678910111213141516171819202122232425262728table&#123; /* 通用属性 */ width: 300px; height: 300px; text-align: center; /* 设置的单元格相邻边是否被合并 separate: 单元格边框独立，默认 collapse： 边框合并（变成实心的实现） */ border-collapse: collapse; /* 设置单元格边框边距，只有在border-collapse为separate情况下才有用 */ border-spacing: 10px; /* 标题方位 top, bottom */ caption-side: top; /* 空内容单元格的是否显示,hide */ empty-cells: hide; /* 表格的排版方式 auto: 内容过长的时候，会拉伸整个单元格，挤压其他单元格 fixed： 内容过长时，不会拉伸，会换行处理 */ table-layout: fixed; &#125; 12345678910111213141516171819202122232425&lt;link rel="stylesheet" type="text/css" href="style.css"&gt;&lt;table border="1"&gt; &lt;caption&gt;人员表格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;34&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;43&lt;/td&gt; &lt;/tr&gt; 2. 列表样式12345678910111213141516171819ul&#123; /* 更改列表前面的实心圆标记 none,disc(实心圆), circle(空心圆), square(实心方块), decimal(阿拉伯数字), lower-roman, upper-roman, lower-alpha, upper-alpha */ list-style-type: circle; /* 标记位于内容框的内部还是外部，换行的时候才有效果 outside: 内容库外部 inside：内容库内部 */ list-style-position: inside; /* 使用图片作为前缀的标记: none, url */ list-style-image: url(bullet.png); /* 简写形式：type position image */ list-style: lower-alpha inside url(bullet.png); &#125; 1234567&lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt; &lt;li&gt;六七&lt;/li&gt; &lt;li&gt;八器&lt;/li&gt;&lt;/ul&gt; 3. 其他功能3.1. 表格内容垂直对齐1234.sex&#123; /* 设置单元格内容的对齐方式,baseline,top,middle,bottom */ vertical-align: bottom;&#125; 4. CSS其他样式4.1. 颜色和透明度12345678p&#123; /* 设置文本颜色 */ color: red; /* 设置文本透明度, 对于前景色和背景色都有作用 */ opacity: 0.5;&#125; 4.2. 盒子阴影轮廓12345p&#123; 设置盒子的阴影和颜色 水平偏移量，垂直偏移量，模糊值(越大越模糊),阴影延伸的半径，阴影颜色,外部阴影为内部阴影 box-shadow: 10px 10px 1px 10px gray inset;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程04-边框和背景设置]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B04-%E8%BE%B9%E6%A1%86%E5%92%8C%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 定义边框1.1. 边框属性边框的声明有三个属性需要设置 属性 值 说明 border-width 长度值 边框宽度 border-style 样式名称 边框样式 border-color 颜色值 边框颜色 border width style color; 语句简写 border-top width style color; 顶部边框简写 border-bottom width style color; 上同 border-left width style color; 上同 border-right width style color; 上同 其中，border-style一共有多种选择 none： 无边框 dashed： 破折线边框 dotted： 圆点线边框 double： 双线边框 groove： 槽线边框 inset： 使元素内容具有内嵌效果的边框 outset： 使元素内容具有外凸效果的边框 ridge： 脊线边框 solid： 实线边框 123456789div&#123; width: 200px; height: 200px; /* 定义边框，这三个必须写 */ border-style: solid; border-color: red; border-width: 10px;&#125; 1.2. 圆角边框通过border-radius设置 1234div&#123; /* 同时这个四个角的幅度 */ border-radius: 10px;&#125; 2. CSS背景设置背景属性盒模型的尺寸可以通过两种方式进行可视化，一种是之前的边框，第二种是背景 属性 值 shuom background-color 颜色或者transparent 背景颜色 background-image none或者url 背景图片 background-repeat 样式名称 背景图片样式 background-size 长度值 背景图像的尺寸 background-position 位置坐标 背景图像的位置 background-attachment 滚动方法 背景图片的滚动 background-clip 裁剪方式 背景图片的裁剪 background-origin 位置坐标 背景图片的开始点 background 复合值 背景图片简写方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344div&#123; background-color: silver; background-image: url(img.jpg); /* repeat-x: 水平平铺 repeat-y: 垂直平铺 repeat: 全平铺 no-repeat： 禁止平铺，只显示一个图片 */ background-repeat: no-repeat; /* top,left,right,bottom,center */ background-position: center; /* auto: 默认，图像以原有尺寸显示 cover: 等比例缩放图像，使得图像至少覆盖容器，但有可能超出 contain: 等比例缩放图像，使得宽度、高度最大的与容器横向或者纵向重合 长度值：长，高 百分比： */ background-size: cover; background-size: 100px 100px; /* 滚动时内容和背景是否同时滚动 scroll: 滚动 fixed：不滚动 */ background-attachment: fixed; /* 背景的绘制方案，绘制的开始点： border-box: 在元素盒子内部绘制背景，嵌入边框 padding-box: 在内边距盒子内部绘制，不嵌入边框 content-box： 在内容盒子内部绘制，从内容左上角开始绘制 */ background-origin: padding-box; /* 背景的绘制方案，绘制的裁剪点： border-box: 在元素盒子内部裁剪背景，嵌入边框 padding-box: 在内边距盒子内部裁剪，不嵌入边框 content-box： 在内容盒子内部裁剪，从内容左上角开始绘制 */ background-clip: border-box; /* 简写方式 color,image, repeat, position, /size, origin, clip: */ background: silver url(dog.jpg) no-repeat top left / 100% border-box content-box;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程03-盒模型]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B03-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1.CSS盒模型元素的尺寸，大小，内外边距和溢出问题 1.1. 元素尺寸 属性 说明 属性值 width 元素的宽度 auto,长度值或百分比（相对于body长度） height 元素的高度 auto,长度值或百分比（相对于body长度）. min-width 元素的最小宽度 auto,长度值或百分比 min-height 元素的最小高度 auto,长度值或百分比 max-width 元素的最大宽度 auto,长度值或百分比 max-height 元素的最大高度 auto,长度值或百分比 1234div&#123; width: 200px; height: 200px;&#125; 1.2. 元素内边距 属性 说明 属性值 padding-top 顶部内边距 长度值或者百分比 padding-bottom 底部内边距 长度值或者百分比 padding-left 左边内边距 长度值或者百分比 padding-right 右边内边距 长度值或者百分比 padding 简写属性 1-4个长度值或者百分比 12345678910div&#123; /* 上下左右同时空出10px */ padding: 10px; /* 上下10个，左右20个 */ padding: 10px 20px; /* 上，右，下，左 */ padding: 10px 20px, 10px, 20px;&#125; 1.3. 元素外边距 属性 说明 属性值 margin-top 顶部外边距 长度值或者百分比 margin-bottom 底部外边距 长度值或者百分比 margin-left 左边外边距 长度值或者百分比 margin-right 右边外边距 长度值或者百分比 margin 简写属性 1-4个长度值或者百分比 1.4. 处理溢出当设置div长度后，文本长度超过div尺寸就会存在溢出，那么如何处理溢出后的内容呢？ 通过overflow系列样式来控制 overflow的值如下： 值 说明 auto 浏览器自行处理溢出内容，有溢出就显示滚动条 hidden 有溢出就直接剪掉溢出内容 scroll 不管是否溢出，都会出现滚动条，但不同平台和浏览器显示方式不同 visible 默认值，不管是否溢出，都显示内容 123div&#123; overflow: auto;&#125; 2. CSS盒子类型2.1. 元素可见性visibility visible： 元素页面可见 hidden: 元素不可见，但是会占据空间 collapse: 元素不可见，隐藏表格的行列 123div&#123; visibility: hidden;&#125; 2.2. 元素的盒类型display属性 block： 盒子为块级元素 inline： 盒子为行内元素 inline-block： 盒子为行内-块元素 none： 盒子不可见，不占位 1234567891011121314 /* 块级元素--》 行内元素 */div&#123; display: inline;&#125;/* 行内元素---》块级元素 */span&#123; display: block;&#125; /* 全部转为行内-块元素 */div,span&#123; display: inline-block&#125; 2.2.1. 块级元素能够设置元素尺寸，隔离其他元素功能(换行)的元素，比如：&lt;div&gt;,&lt;p&gt;等文档元素 12345div&#123; background: silver; width: 200px; height: 200px&#125; 2.2.2. 行内元素行内元素不可用设置元素尺寸大小，它只能自适应，无法隔离其他元素，其他元素会紧跟在其后面，比如&lt;span&gt;,&lt;b&gt;元素等 2.2.3. 行内-块元素所谓行内-块元素，可设置元素尺寸，但是无法隔离器其他元素的元素，比如&lt;img&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS教程02-字体及文本内容设置]]></title>
    <url>%2F2019%2F03%2F06%2FCSS%E6%95%99%E7%A8%8B02-%E5%AD%97%E4%BD%93%E5%8F%8A%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. CSS文本样式1.1. 字体设置 属性名 说明 font-size 设置字体大小 font-variant 设置英文字体是否转换为小型大写 font-style 设置字体是否倾斜 font-weight 设置字体是否加粗 font-family 设置font字体 font 设置字体样式复合写法 @font-face 设置Web字体 1234567891011121314151617181920p &#123; font-size: 20px; /* 主要为normal和small-caps */ font-variant: normal; /* 文字倾斜 */ font-style: italic; /* 字体加粗 */ font-weight: bold; /* 设置字体 */ /* 可以设置备用字体，根据先后顺序排列 */ font-family: 楷体，微软雅黑，宋体; /* 字体大小和字体必须放在后面 */ font: italic bold 50px 楷体; &#125; 1.2. 文本内容样式 属性名 说明 属性值 text-decoration 装饰文本出现各种划线 none,overline,line-through,underline text-transform 将英文文本转为大小写 none, uppercase,lowercase,capitalize(首字母大写) text-shadow 给文本添加阴影 text-align 设置文本对齐方法 left,right,center,justify white-space 排版中的空白处理方式 normal,nowrap,pre,pre-line,pre-wrap letter-spacing 设置字母之间的间距 5px word-spacing 设置单词之间的间距 5px line-height 设置行高 150%（百分比最常用） word-wrap 控制段词,让过长的英文单词断开 normal, break-word text-indent 设置为文本首行缩进 20px 12345678910111213141516171819202122232425p&#123; /* 下划线 */ text-decoration: underline; /* 转小写 */ text-transform: lowercase; /* 添加阴影 水平偏移，垂直偏移，阴影模糊度，阴影颜色 */ text-shadow: 5px 5px 3px black; /* 文本对齐方式 */ /* justify两端对齐 */ text-align: justify; /* white-space处理空白 normal: 空白符被压缩，文本自动换行 nowrap： 空白符被压缩，文本不换行 pre: 空白符被保留，遇到换行符换行 pre-line: 空白符被压缩，文本会在排满或者遇到换行符换行 pre-wrap： 空白符被保留，文本会子啊排满或遇到换行符换行 */ white-space: nowrap; &#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类的继承]]></title>
    <url>%2F2019%2F03%2F05%2FJava%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 继承extends一个类得到另外一个类的成员变量和成员函数，java只支持单继承 继承的特点： 自动获得父类的成员变量和成员函数 子类可以定义自己的成员函数(扩展父类的功能) 将通用成员变量和函数定义在父类中，子类通过继承获取，来减少重复代码 子类可以覆盖父类的一些方法 子类通过super调用父类的方法 子类通过super调用父类构造器（子类构造函数中，必须调用父类的构造函数） 如果没有super调用父类构造器，将自动调用父类的默认构造器 首先写父类 123456789101112131415161718192021222324252627class Person&#123; String name; int age; Person()&#123; System.out.println("无参数"); &#125; Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println("有参数"); &#125; void eat()&#123; System.out.println("吃饭"); &#125; void introduce()&#123; System.out.println("我的名字是" + name + ", 我的年龄是" + age); &#125; String getName()&#123; return self.name; &#125;&#125; 然后写子类 12345678910111213141516171819202122232425class Student extends Person&#123; // 自动获得父类的成员变量和成员函数 // 可以定义自己的成员变量和函数 int grade; void study()&#123; System.out.println("学习"); &#125; Student(String name, int age, int grade)&#123; // 可以通过super调用父类构造函数 super(name, age); this.grade = grade; &#125; // 可以覆盖父类的函数 void eat()&#123; String name = super.getName(); System.out.println("父类的名字是： " + name); &#125;&#125; 在main方法中写 1234567class Test&#123; public static void main(String args[])&#123; Student student = new Student(); student.name = "zhang"; student.eat(); &#125;&#125; 2. 理解方法的调用分析x.f(args)这个调用的主要流程 (1). 编译器查看对象的声明类型和方法名，检查到x是C类的对象(2). 编译器将查看调用方法时提供的参数类型，根据输入的参数，来判断调用哪一个f方法-重载解析(3). 如果方法时static,final,private或者是一个构造器的时候，编译器可以精确定位，也称为静态绑定，与此对应，调用的方法依赖于x的实际类型，并且在运行时动态绑定(4). 当程序运行的时候，并且动态绑定后，须立即一定调用与x所引用对象的实际类型最合适的那个方法，假设x的实际类型是D，它是C类的子类，如果D类定义了f函数，就直接调用，否则会从D的父类里面找这个函数 3. 阻止继承: final类和方法不允许扩展的类为final类 123public final class Executive extends Manager&#123;&#125; 4. 对象转型4.1. 向上转型将子类的对象赋值给父类的引用 一个引用能够调用哪个成员变量和方法，取决于这个引用的类型 一个引用调用的是哪一个方法，取决于这个引用指向的对象 1234567891011121314151617181920212223// 父类class Person&#123; String name; int age; void introduce()&#123; System.out.println("name: " + name + "age" + age); &#125;&#125;// 子类class Student extends Person&#123; String address; void study()&#123; System.out.println("study "); &#125; void introduce()&#123; super.introduce(); System.out.println("address: " + address); &#125;&#125; 在主main函数中 12345678910111213141516171819class test&#123; public static void main(String args[])&#123; Student s = new Student(); Person p = s; // 一个引用能够调用哪个成员变量或者函数，取决于这个引用的类型 // p只能有name和age变量 // p只能调用introduce方法 // 一个引用调用的是哪一个方法，取决于这个引用指向的对象 // p调用的introduce方法，实际上是student中的复写后的introduce方法 p.name = "zhang"; p.age = 20; // p.address = "CQ"; // 这个会出错 // p.study(); // 出错 // 实际上是s.introduce() p.introduce(); &#125;&#125; 4.2. 向下转型将父类的对象赋值给子类的引用 123456789class test&#123; public static void main(String args[])&#123; Student s1 = new Student(); Person p = s1; Student s2 = (Student)p; &#125;&#125; 4.3.面向对象多态性的例子目标： 开发一个打印机控制程序，能够实现开机，关机和打印功能, 能够控制不同打印机设计： 建立一个printer类 1234567891011121314151617181920212223242526272829303132// 将相同的代码放到父类中class Printer&#123; void open()&#123; System.out.println("open") &#125; void close()&#123; System.out.println("close") &#125; void print(String s)&#123; System.out.println("print---&gt;" + s) &#125;&#125;// 子类复写父类的代码，用于新增功能class CanonPrinter extends Printer&#123; void close()&#123; this.clean(); super.close(); &#125; void clean()&#123; System.out.println("clean"); &#125;&#125;class HPPrinter extends Printer&#123;&#125; 添加一个主函数测试 123456789101112131415161718192021class Test&#123; public static void main(String args[])&#123; int flag = 0; if (flag ==0)&#123; HPPrinter hpprinter = new HPPrinter(); hpprinter.open(); hpprinter.print("123"); hpprinter.close(); &#125; else if (flag ==1)&#123; CanonPrinter canonPrinter = new CanonPrinter(); canonPrinter.open(); canonPrinter.print("456"); canonPrinter.close(); &#125; &#125;&#125; 5. 抽象类5.1. 抽象函数abstract只有函数的定义，没有函数体的函数 1abstract void fun(); 5.2. 抽象类通过abstract定义的类 抽象类不能够生成对象 因为一旦生成对象，调用里面的抽象函数时，java不知道做什么 如果一个类当中包含抽象函数，那么这个类必须声明为抽象类 如果一个类中没有抽象函数，也可以声明为抽象类 抽象类天生就是当爹的，它的子类可以生成对象 当子类继承抽象类的时候，必须复写抽象类中的抽象函数 抽象类可以有构造函数 这种继承抽象类和继承普通类的优点在哪里？ 代码检查，必须重写抽象类中的抽象方法 12345678910111213141516171819202122232425262728293031abstract class Person&#123; String name; int age; // 抽象类可以有构造函数 Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println("Person的构造函数"); &#125; void introduce()&#123; System.out.println("我的名字:"+name + "，我的年龄是:"+age); &#125; abstract void fun();&#125;// 子类继承抽象类的时候，必须复写抽象函数class Chinese extends Person&#123; String address; void Chinese(String name, int age, String address)&#123; super(name,age); this.address = address; &#125; void eat()&#123; System.out.println("用筷子吃饭"); &#125;&#125; 在主函数中 12345678class Test&#123; public static void main(String args[])&#123; // 向上转型 Person p = new Chinese(); // 虽然p是抽象类，但是他指向的是chinese这个引用，调用的是chinese的eat p.eat(); &#125;&#125; 6. 包和访问权限6.1. 将类放到包中什么是软件包? 怎么讲类放到软件包中? 将类放到一个包中，需要使用packcage “包名” 编译时需要使用 -d参数，该参数的作用是依照包名生成相应的文件夹 一个类的全名: 包名 + . + 类名：mars.Test 包名的命名规范 一般小写 一般是域名倒过来写: io.github.com.haochen95; 1234567package mars;class Test&#123; public static void main(String[] args)&#123; System.out.println("package") &#125;&#125; 6.2. 包的访问权限 访问权限 含义 包内可否使用 包之间可否使用 包内继承 包间继承 public 公有权限 Yes Yes Yes Yes private(很少修饰类) 私有权限 No No No No default 包级别访问权限 Yes No Yes No protected(不修饰类) 受保护权限 Yes No Yes Yes(只有子类才能使用)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS语法教程01]]></title>
    <url>%2F2019%2F03%2F05%2FCSS%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B01%2F</url>
    <content type="text"><![CDATA[[TOC] 1.CSS基础语法css样式是由一条和多条以分好隔开的样式声明组成 1&lt;p style="color:red;font-size:50px;"&gt;这是一段文本&lt;/p&gt; 1.1. 创建CSS样式表的三种方法元素内嵌样式123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在这里定义style--&gt; &lt;p style="color:red;font-size:50px;"&gt;这是一段文本&lt;/p&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 2.文档内嵌样式通过在head设置全局的样式： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS语法&lt;/title&gt; &lt;!--在这里定义style--&gt; &lt;style type="text/css"&gt; p &#123; color: blue; font-size: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 3.外部引入样式这是最常用的一种方式，包括 创建一个外部的CSS文件style.css 用于设置字体颜色和大小 123456@charset "UTF-8";p &#123; color: red; font-size: 40px;&#125; 在创建一个外部CSS文件test.css用于设置文字斜体 12345@charset "UTF-8";b&#123; font-style: italic;&#125; 在html文件中引用多个CSS文件 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS语法&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="style.css"&gt; &lt;link rel="stylesheet" type="text/css" href="test.css"&gt; &lt;style type="text/css"&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一段&lt;b&gt;文本&lt;/b&gt;&lt;/p&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; 1.2. 样式层叠和继承样式层叠： 同一个元素通过不同方式设置样式表产生的样式重叠样式继承： 某一个被嵌套的元素得到它的父元素样式 浏览器样式 浏览器本身自带的样式 12&lt;b&gt;b元素本身就有加粗样式&lt;/b&gt; &lt;br&gt;&lt;span style="font-weight: bold;"&gt;span本身没有家畜，但是可以自己设置家畜&lt;/span&gt; 1.2.2. 样式层叠样式层叠通过五种方法进行(优先级从低到高，4最高) 浏览器样式：自带样式 外部引用样式(&lt;linl&gt;引入) 文档内嵌样式(&lt;style&gt;设置) 元素内嵌样式(使用style属性) 自定义强制性优先级(important) 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS语法&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="style.css"&gt; &lt;link rel="stylesheet" type="text/css" href="test.css"&gt; &lt;style type="text/css"&gt; p &#123; color: green important; font-size: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p style="color:red"&gt;我要叠加三种样式&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 1.2.3. 样式继承1&lt;p style="color:red"&gt;这是&lt;b&gt;HTML&lt;/b&gt;&lt;/p&gt; 你会发现整段文本就会是红色的，虽然我并没设置b元素为红色 样式继承只用于元素的外观(文字，颜色，字体等)，布局样式不会被继承 1234567&lt;style type="text/css"&gt; p &#123; border: 1px solid red; &#125;&lt;/style&gt;&lt;p&gt;这是&lt;b&gt;HTML&lt;/b&gt;&lt;/p&gt; 这时候p元素有外边框，但是b元素没有 2. CSS选择器CSS选择器就是定外到你想要的设置的元素，然后对他进行样式设置，主要分为 基本选择器 复合选择器 伪元素选择器 选择器 名称 说明 * 通用选择器 选择所有的元素 &lt;type&gt; 元素选择器 选择指定类型的元素 #&lt;id&gt; id选择器 选择指定id属性的元素 &lt;class&gt; class选择器 选择指定class属性的元素 [attr] 属性选择器 选择指定attr属性的元素 s1,s2,s3... 分组选择器 选择多个选择器的元素 s1 s2 后代选择器 选择指定选择器的后代元素 s1&gt;s2 子选择器 选择指定选择器的子元素 s1+s2 相邻兄弟选择器 选择指定选择器相邻的元素 s1~s2 普通兄弟选择器 选指定选择器后面的元素 ::first-line 伪元素选择器 选择块级元素文本的首行 ::first-letter 伪元素选择器 选择块级元素文本的首字母 ::before 伪元素选择器 选择元素之前插入内容 ::after 伪元素选择器 选择元素之后插入内容 2.1. 通用选择器123456@charset "UTF-8";*&#123; border: 1px solid red;&#125;/*通用选择器还匹配到了html和body元素*/ 2.2. 元素选择器12345@charset "UTF-8";p&#123; color: red;&#125; 2.3. id选择id只能是一个全局唯一样式 这个选择器只能设置一个元素 在css文件中 12345@charset "UTF-8";#abc &#123; color: green;&#125; 在html中 1&lt;p id="abc"&gt;这是HTML&lt;/p&gt; 2.4. 类选择器为了补偿id选择器的缺点，可以一下子设置多个元素样式 在css文件中 123456789101112131415@charset "UTF-8";/*用.定义*/.abc &#123; color: green;&#125;/*只能b元素的abc才有效果*/b.abc &#123; color: green;&#125;.def &#123; font-size: 40px;&#125; 在html中 123&lt;p class="abc"&gt;这是HTML&lt;/p&gt;&lt;b class="abc"&gt;哈哈哈哈&lt;/b&gt;&lt;p class="abc def"&gt;同时使用多个class的style&lt;/p&gt; 2.5. 属性选择器直接通过两个中括号里面包含属性名来设置 在css文件中 123456789101112131415161718192021222324252627282930@charset "UTF-8";/*属性匹配*/[href] &#123; color: orange;&#125;/*属性+内容 匹配*/[tyep="password"] &#123; border: 1px solid red;&#125;/*属性+正则 匹配*/[href^="http"] &#123; color: orange;&#125;[href$=".cn"] &#123; color: orange;&#125;/*属性+模糊查询 匹配*/[href*="baidu"] &#123; color: orange;&#125;/*属性有多个值时，匹配其中一个 匹配*/[class~="edf"] &#123; color: orange;&#125; 在html中 123&lt;a href="www.baidu.com"&gt;百度&lt;/p&gt;&lt;input type="password"&gt; 2.6. 复合选择器将不同的选择器进行组合形成新的特定匹配 在css文件中 123456789101112131415161718192021222324252627282930313233343536@charset "UTF-8";/* 分组选择器 *//* 匹配所有的p,b,i,span元素 */p,b,i,span &#123; color: green;&#125;#abc, .abc, i, span&#123; color: green;&#125;/* 后代选择器 *//* 不在乎b到底是第几代 */p b&#123; color: red;&#125;/* 子选择器 *//* b只能是p的儿子，孙子就不行了 */p&gt;b&#123; color: red;&#125;/* 相邻兄弟选择器 *//* 在html中，两个元素靠在一起 */p+b&#123; color: red;&#125;/* 普通兄弟选择器 *//* 中间可以有其他元素隔开 */p~b&#123; color: red;&#125; 2.7. 伪元素选择器123456789101112131415161718192021/* 块级首行 *//* 在p,div，body等块级元素才有效果 */::first-line&#123; color: red;&#125;/* 块级首字母 */::first-letter&#123; color: red;&#125;/* 文本前插入内容 */a::before&#123; content: '点击-';&#125;/* 文本后插入内容 */a::after&#123; content: '搜索';&#125; 2.8. 伪类选择器 选择器 名称 说明 :root 根元素选择器 选择文档的根元素 :first-child 子元素选择器 选择元素的第一个子元素 :last-child 子元素选择器 选择元素的最后一个子元素 :only-child 子元素选择器 选择元素中的唯一子元素 :only-of-type 子元素选择器 选择指定类型的唯一元素 :nth-child 子元素选择器 选择指定N个子元素 :enabled UI选择器 选择启用状态元素 :disabled UI选择器 选择禁用状态元素 :checked UI选择器 选择被选中input勾选元素 :default UI选择器 选择默认元素 :valid UI选择器 验证有效选择input元素 :invalid UI选择器 验证无效选择input元素 :required UI选择器 有require属性的元素 :optional UI选择器 没有required属性的元素 :link 动态选择器 未访问的超链接元素 :visited 动态选择器 已经访问的超链接元素 :hover 动态选择器 悬停在超链接上的元素 :active 动态选择器 激活超链接上的元素 :focus 动态选择器 获取焦点的元素 :not 其他选择器 否定选择的元素 :empty 其他选择器 选择没有内容的元素 :lang 其他选择器 选择包含lang属性的元素 :target 其他选择器 选取URL片段标识指向元素 2.8.1. 结构性伪类选择器根据元素在文档中的位置选择元素，伪类都需要加入前置选择器来限制范围 12345678910111213141516171819202122232425262728293031323334353637:root &#123; border: 1px solid red;&#125;/* ul&gt;li 来限制范围 *//* 选择第一个子元素 */ul &gt; li:first-child&#123; color: red;&#125;ul &gt; li:only-child&#123; color: red;&#125;/* 选择第二个儿子 */ul &gt; li:nth-child(2)&#123; color: red;&#125;/* 选择倒数第二个儿子 */ul &gt; li:nth-last-child(2)&#123; color: red;&#125;div &gt; p:only-of-type&#123; color: red;&#125;div &gt; p:nth-of-type(2)&#123; color: red;&#125;div &gt; p:nth-last-of-type(2)&#123; color: red;&#125; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;CSS语法&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="style.css"&gt; &lt;style type="text/css"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;我是儿子1&lt;/li&gt; &lt;li&gt;我是儿子2&lt;/li&gt; &lt;li&gt;我是儿子3&lt;/li&gt; &lt;li&gt;我是儿子4&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;p&gt;这是一个段落&lt;/p&gt; &lt;span&gt;这是另外一个段落&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.8.2. UI伪类选择器主要用于匹配表单form控件 1234567891011121314151617181920input:enabled&#123; border: 1px solid red;&#125;input:disabled&#123; border: 1px solid blue;&#125;input:checked&#123; display: none;&#125;input:valid&#123; border: 1px solid green;&#125;input:invalid&#123; border: 1px solid red;&#125; 123456789101112&lt;form&gt; &lt;input type="text" disabled&gt; &lt;input type="text"&gt; &lt;input type = "checkbox" checked&gt; &lt;input type = "checkbox"&gt; &lt;input type="email" required&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; 2.8.3. 动态选择器跟鼠标有关 123456789101112131415161718192021222324a:link&#123; color: red;&#125;a:visited&#123; color: blue;&#125;/* 悬停状态的颜色 */a:hover&#123; color: orange;&#125;/* 鼠标点下去不松的状态 */a:active&#123; color: green;&#125;/* focus是对文本框的设置 *//* 获取光标焦点时的样式 */input:focus&#123; border: 1px solid red;&#125; 1&lt;a href = "www.baidu.com"&gt;百度&lt;/a&gt; 2.8.4. 其他选择器12345678910111213/* 选择除baidu外的其他URL */a:not([href*="baidu"])&#123; color:red;&#125;p:empty&#123; display: none;&#125;p:lang(en)&#123; color:red;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML语法大全之代码实现]]></title>
    <url>%2F2019%2F03%2F05%2FHTML%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h1&gt;1.文本元素&lt;/h1&gt;b元素（加粗）： 这是&lt;b&gt;HTML&lt;/b&gt;教程 &lt;br&gt;strong元素（加粗）： 这是&lt;strong&gt;HTML&lt;/strong&gt;教程 &lt;br&gt;wbr元素(安全换行)： this is &lt;wbr&gt;asdfasdgasdgfasdfasdf is apple &lt;br&gt;i元素(倾斜)： 这是&lt;i&gt;HTML&lt;/i&gt;教程&lt;br&gt;em元素(倾斜): 这是&lt;em&gt;HTML&lt;/em&gt;教程&lt;br&gt;var元素(倾斜): 这是&lt;var&gt;HTML&lt;/var&gt;教程&lt;br&gt;s元素(删除线):这是&lt;s&gt;HTML&lt;/s&gt;教程&lt;br&gt;del元素(删除线): 这是&lt;del&gt;HTML&lt;/del&gt;教程&lt;br&gt;u元素(下划线): 这是&lt;u&gt;HTML&lt;/u&gt;教程&lt;br&gt;ins元素(下划线): 这是&lt;ins&gt;HTML&lt;/ins&gt;教程&lt;br&gt;small元素(放小字体): 这是&lt;small&gt;HTML&lt;/small&gt;教程&lt;br&gt;sub元素(下标): 这是HTML&lt;sub&gt;5&lt;/sub&gt;教程&lt;br&gt;sup元素(上标): 这是HTML&lt;sup&gt;5&lt;/sup&gt;教程&lt;br&gt;code元素(代码块): 这是&lt;code&gt;HTML&lt;/code&gt;教程&lt;br&gt;kdb元素(用户输入): 这是&lt;kdb&gt;HTML&lt;/kdb&gt;教程&lt;br&gt;abbr元素(缩写): 这是&lt;abbr&gt;HTML&lt;/abbr&gt;教程&lt;br&gt;dfn元素(表示术语): 这是&lt;dfn&gt;HTML&lt;/dfn&gt;教程&lt;br&gt;q元素(双引号): 这是&lt;q&gt;HTML&lt;/q&gt;教程&lt;br&gt;cite元素(引用标题): 这是&lt;cite&gt;HTML&lt;/cite&gt;教程&lt;br&gt;bdo元素(文字方向): 这是&lt;bdo dir="rtl"&gt;HTML&lt;/bdo&gt;教程&lt;br&gt;mark元素(突出显示): 这是&lt;mark&gt;HTML&lt;/mark&gt;教程&lt;br&gt;time元素(时间): 这是&lt;time&gt;2019-01-01&lt;/time&gt;教程&lt;br&gt;span元素(跟CSS搭配): 这是&lt;span&gt;HTML&lt;/span&gt;教程&lt;br&gt;&lt;h1&gt;2.超链接和路径&lt;/h1&gt;&lt;a href="http://www.baidu.com"&gt;BaiDu&lt;/a&gt; &lt;br&gt;&lt;!--新开一个窗口进入百度--&gt;&lt;a href="http://www.baidu.com" target="_blank"&gt;BaiDu&lt;/a&gt; &lt;br&gt;&lt;!--相对路径--&gt;&lt;a href="html_01.html"&gt;转入第二页&lt;/a&gt; &lt;br&gt;&lt;a href="../html_01_second.html"&gt;转入父目录&lt;/a&gt; &lt;br&gt;&lt;a href="http://www.baidu.com" title="跳到百度"&gt; &lt;img src="https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" alt="google"&gt;&lt;/a&gt; &lt;br&gt;&lt;a href="#"&gt;自动跳到页面顶部&lt;/a&gt; &lt;br&gt;&lt;h1&gt;3.锚点链接(页面内定位)&lt;/h1&gt;&lt;a href="#1"&gt;第一章&lt;/a&gt; &lt;a href="#2"&gt;第二章&lt;/a&gt; &lt;a href="#3"&gt;第三章&lt;/a&gt; &lt;br&gt;&lt;h1&gt;4.分组元素&lt;/h1&gt;&lt;!--段落--&gt;&lt;p&gt;这是一个段落&lt;/p&gt;&lt;p&gt;这是另外一个段落&lt;/p&gt;&lt;!--通用分组与段落类似--&gt;&lt;div&gt;这是一个通用分组&lt;/div&gt;&lt;div&gt;这是另外一个通用分组&lt;/div&gt;&lt;!--引用大段落来自其他内容--&gt;&lt;blockquote&gt;这是一个来自其他内容的引用&lt;/blockquote&gt;&lt;blockquote&gt;这是另外一个来自其他内容的引用&lt;/blockquote&gt;&lt;!--展示格式化内容(编辑器怎么排版，我就怎么排版)--&gt;&lt;pre&gt; ######## ######### #######&lt;/pre&gt;&lt;!--添加水平线--&gt;&lt;hr&gt;&lt;h2&gt;4.1. 列表&lt;/h2&gt;无序列表:&lt;br&gt;&lt;ul&gt; &lt;li&gt;&lt;a href="https://www.google.com.hk/"&gt;张三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt;&lt;/ul&gt; &lt;br&gt;有序列表：&lt;br&gt;&lt;ol start="2"&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li value="8"&gt;李四&lt;/li&gt; &lt;li&gt;王五&lt;/li&gt;&lt;/ol&gt; &lt;br&gt;生成说明列表(概念和概念的解释)：&lt;br&gt;&lt;dl&gt; &lt;dt&gt;这是第一份文件&lt;/dt&gt; &lt;dd&gt;这是第一份文件的详细信息1&lt;/dd&gt; &lt;dd&gt;这是第一份文件的详细信息2&lt;/dd&gt; &lt;dt&gt;这是第二份文件&lt;/dt&gt; &lt;dd&gt;这是第二份文件的详细信息1&lt;/dd&gt; &lt;dd&gt;这是第二份文件的详细信息2&lt;/dd&gt;&lt;/dl&gt; &lt;br&gt;图片链接: &lt;br&gt;&lt;figure&gt; &lt;figcaption&gt;这是一张图片&lt;/figcaption&gt; &lt;img src = "img/dog.jpg"&gt;&lt;/figure&gt;&lt;h1&gt;5.表格元素&lt;/h1&gt;构建基本的表格：&lt;!--cellpadding: 内容和边框的距离--&gt;&lt;!--cellspacingg: 格子之间的距离--&gt;&lt;table border="1" width="500" height = "300" cellpadding="10" cellspacing = "10"&gt; &lt;!--表的标题--&gt; &lt;caption&gt;这是标题&lt;/caption&gt; &lt;!--设置某一列为红色--&gt; &lt;colgroup&gt; &lt;!--第一列不设置--&gt; &lt;col&gt; &lt;!--第二列为红色--&gt; &lt;col style = "background: red;" span = "1"&gt; &lt;/colgroup&gt; &lt;!--tr表示一行--&gt; &lt;tr&gt; &lt;!--th表示表头--&gt; &lt;!--valign表示垂直对齐--&gt; &lt;th valign="top"&gt;序号&lt;/th&gt; &lt;th&gt;产品名称&lt;/th&gt; &lt;th&gt;产品价格&lt;/th&gt; &lt;th&gt;产品数量&lt;/th&gt; &lt;th&gt;统计&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--colspan表示水平合并--&gt; &lt;td colspan="5"&gt;水平合并&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--td表示一格--&gt; &lt;!--align表示水平对齐--&gt; &lt;td align="center"&gt;1&lt;/td&gt; &lt;td align="center"&gt;苹果&lt;/td&gt; &lt;td&gt;￥5.00&lt;/td&gt; &lt;td&gt;1000&lt;/td&gt; &lt;!--rowspan表示垂直合并--&gt; &lt;td rowspan="3"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;橘子&lt;/td&gt; &lt;td&gt;￥6.00&lt;/td&gt; &lt;td&gt;2000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;葡萄&lt;/td&gt; &lt;td&gt;￥16.00&lt;/td&gt; &lt;td&gt;2300&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;br&gt;&lt;h1&gt;6.传统表格&lt;/h1&gt;&lt;table width = "800" height="800" border="1" cellpadding="0" cellspacing="0" align="center"&gt; &lt;tr&gt; &lt;td width="260" valign="top" bgcolor="#f2f2f2"&gt; &lt;table width="260" border="0" cellpadding="0" cellspacing="0" align="center"&gt; &lt;tr height="100"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="230" align="right"&gt;&lt;img src="https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png" widht="200"&gt;&lt;/td&gt; &lt;td width="30"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="right"&gt;Google&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="right"&gt;13251361449&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align="right"&gt;13251361449@qq.com&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td width="30"&gt;&lt;/td&gt; &lt;td width="480"&gt;&lt;/td&gt; &lt;td width="30"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h1&gt;7.文档元素&lt;/h1&gt;标题: &lt;br&gt;&lt;header&gt; 这里存放页面的表头部分：LOGO,标题，导航等. &lt;hgroup&gt; &lt;h1&gt;这是大标题&lt;/h1&gt; &lt;h4&gt;这是一个副标题&lt;/h4&gt; &lt;/hgroup&gt; &lt;nav&gt; 这里是一个导航 &lt;/nav&gt;&lt;/header&gt;主题部分: &lt;br&gt;&lt;section&gt; 这是文档的主题部分&lt;/section&gt;&lt;article&gt; 这是一个文档 &lt;header&gt;...&lt;/header&gt; &lt;section&gt;...&lt;/section&gt; &lt;footer&gt;...&lt;/footer&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;页面尾部: &lt;br&gt;&lt;footer&gt; 这里是页面尾部，版权啊，等等 &lt;address&gt; 这里是联系信息 &lt;/address&gt;&lt;/footer&gt;&lt;br&gt;&lt;h1&gt;8.内嵌框架&lt;/h1&gt;&lt;h2&gt;8.1.插入图片&lt;/h2&gt;插入图片：&lt;!--alt:加载错误的时候显示的文字，width/height设置长度高度, usemap设置点击图片跳转到另外一个网址--&gt;&lt;img src="img/dog.jpg" alt="狗图" width="200" height="300"&gt; &lt;br&gt;&lt;h2&gt;8.2. iframe的使用&lt;/h2&gt;在页面中插入另外一个frame： &lt;br&gt;&lt;a href="http://www.baidu.com" target="in"&gt;百度&lt;/a&gt; | &lt;a href="http://www.haosou.com" target="in"&gt;好搜&lt;/a&gt;&lt;br&gt;&lt;iframe src="http://www.bilibili.com" frameborder="1" width="800", height="600" name="in"&gt;&lt;/iframe&gt; &lt;br&gt;嵌入插件内容： &lt;br&gt;&lt;!--为了扩展浏览器的功能，--&gt;&lt;embed src="https://www.bilibili.com/video/av10257787/?p=2" width="480" height="400"&gt; &lt;br&gt;进度条： &lt;br&gt;&lt;progress value = "30" max = "100"&gt;&lt;/progress&gt; &lt;br&gt;范围值： &lt;br&gt;&lt;meter value = "30" min = "10" max = "100" low = "40" high="80" optimum="60"&gt;&lt;/meter&gt; &lt;br&gt;&lt;h1&gt;9.音频和视频&lt;/h1&gt;&lt;!--autoplay自动播放，loop反复播放，muted静音, poster是视频开头的图片，preload加载网络video使用，none什么都不加载，metadata下第一帧，auto尽快下载--&gt;&lt;video src="pink.mp4" width="640" height="480" controls poster="img/dog.jpg"&gt;&lt;/video&gt; &lt;br&gt; &lt;br&gt;音频和视频几乎一样（除了没有宽高）: &lt;br&gt;&lt;audio src="xusong.mp3" controls&gt;&lt;/audio&gt; &lt;br&gt;&lt;h1&gt;10.表单元素&lt;/h1&gt;&lt;b&gt;1. form元素（用以用户输入数据）:&lt;/b&gt; &lt;br&gt;&lt;!--action：表单提交的页面， method：用get和post提交，enctype：采用编码格式，name：表单名称，target：提交目标， autocomplete浏览器记住用户数据，novalidate验证性,form让表单为的元素和指定的表单挂钩提交---&gt;&lt;form name="form01" autocomplete="on" action="http://www.haosou.com" id="register"&gt; &lt;!--fieldset对表单进行分组, name+form+disabled--&gt; &lt;fieldset&gt; &lt;!--legend为分组添加标签--&gt; &lt;legend&gt;注册分组&lt;/legend&gt; &lt;!--label可用于CSS--&gt; &lt;label&gt; &lt;!--input属性:autofocus:光标选中，disabled不可输入，autocomplete记住用户，type，name用提交数据的，value的默认值---&gt; 用户名： &lt;input name="User" value="666"&gt; &lt;br&gt; &lt;/label&gt; &lt;label&gt; &lt;!--外部表单控件可以连接form--&gt; 电子邮件： &lt;input name="email" form = "register"&gt; &lt;/label&gt; &lt;!--button属性: type：submit提交/reset重置/button按钮， formaction, formenctype, formmethod, formtarget, formvalidate--&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; &lt;br&gt;&lt;b&gt;2. Input的type属性：&lt;/b&gt; &lt;br&gt;&lt;form&gt; &lt;!--text的属性: maxlength,size, name, value, readonly, disabled, list提供建议值,required必须输入才能提交, palceholder输入字符的提示 --&gt; 文本：&lt;input type="text" list="abc" required&gt; &lt;br&gt; &lt;!--password的属性：与text基本一致--&gt; 密码：&lt;input type="password" placeholder="输入密码吧"&gt; &lt;br&gt; 搜索: &lt;input type="search"&gt; &lt;br&gt; &lt;!--max,min,step,--&gt; 数字: &lt;input type="number"&gt; &lt;br&gt; 范围: &lt;input type="range"&gt; &lt;br&gt; 日期: &lt;input type="date"&gt; &lt;input type="month"&gt; &lt;input type="time"&gt; &lt;input type="week"&gt; &lt;input type="datetime"&gt; &lt;input type="datetime-local"&gt; &lt;br&gt; 颜色: &lt;input type="color"&gt; &lt;br&gt; 复选框: 音乐&lt;input type="checkbox" name="music" value="1"&gt; 体育&lt;input type="checkbox" name="sport" value="2"&gt; &lt;br&gt; 单选框: &lt;input type="radio" name="sex" value="1" checked&gt;男 &lt;input type="radio" name="sex" value="2"&gt;女 &lt;br&gt; 提交: &lt;input type = "submit"&gt; &lt;br&gt; 重置: &lt;input type="reset"&gt; &lt;br&gt; 按钮: &lt;input type="button"&gt;&lt;br&gt; 图片按钮: &lt;input type = "img" src="img/dog.jpg"&gt; &lt;br&gt; email: &lt;input type="email"&gt; &lt;br&gt; telephone: &lt;input type="tel"&gt;&lt;br&gt; URL: &lt;input type="url"&gt;&lt;br&gt; 隐藏:&lt;input type="hidden" value="1"&gt;&lt;br&gt; 上传文件:&lt;input type="file" accept="image/gif"&gt;&lt;br&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;datalist id="abc"&gt; &lt;option value="1"&gt;苹果&lt;/option&gt; &lt;option value="2"&gt;橘子&lt;/option&gt;&lt;/datalist&gt; &lt;br&gt;&lt;b&gt;3. 下拉列表框：&lt;/b&gt; &lt;br&gt;&lt;form action="http://www.haosou.com"&gt; &lt;!--auto,disabled,form size（下拉高度）,multiple（多选）,autofocus, required--&gt; &lt;select name="fruit"&gt; &lt;!--选项分组--&gt; &lt;optgroup label="水果"&gt; &lt;option value="1"&gt;苹果&lt;/option&gt; &lt;option value="2" selected&gt;橙子&lt;/option&gt; &lt;option value="3"&gt;香蕉&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="粗粮"&gt; &lt;option value="4"&gt;大米&lt;/option&gt; &lt;option value="5"&gt;稻谷&lt;/option&gt; &lt;option value="6"&gt;玉米&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; &lt;br&gt;&lt;b&gt;4.多行文本框：&lt;/b&gt; &lt;br&gt;&lt;form action="http://www.haosou.com"&gt; &lt;!--name,form,readonly,disabled,maxlength,autpfocus,placeholder,rows,cols,wrap,requried--&gt; &lt;textarea name="content" cols="30" rows="10"&gt; 请留下你的建议 &lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; &lt;br&gt;&lt;h2&gt;10.1. 标准的form表单写法&lt;/h2&gt;form默认是GET方法提交，直接通过地址信息提交，用于大量文本且不敏感的信息 &lt;br&gt;form可以通过method改为post， 输入的敏感信息就不会再地址中显示出来，用于少量文本且敏感的信息&lt;br&gt;&lt;!-- form表单会提交到这里https://www.google.com.hk/?username=123&amp;pwd=123&amp;gender=0&amp;like=game&amp;like=shopping&amp;site=2&amp;info=hello --&gt;&lt;form action="https://www.google.com.hk"&gt; &lt;div&gt; &lt;!-- for-id的设置可以使得label可点击 --&gt; &lt;label for="username"&gt;用户名：&lt;/label&gt; &lt;!-- name用于在提交地址中显示来定位 --&gt; &lt;input type="text" name="username" id="username"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label for="pwd"&gt;密码：&lt;/label&gt; &lt;input type="password" name="pwd" id="pwd"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type="radio" name="gender" value="0" id="male"&gt;&lt;label for="male"&gt;男&lt;/label&gt; &lt;input type="radio" name="gender" value="1" id="female"&gt;&lt;label for="female"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;input type="checkbox" name="like" value="game"&gt;游戏 &lt;input type="checkbox" name="like" value="sleep"&gt;睡觉 &lt;input type="checkbox" name="like" value="shopping"&gt;购物 &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;个人照片&lt;/label&gt; &lt;input type="file" name=""&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;籍贯：&lt;/label&gt; &lt;select name="site"&gt; &lt;option value="1"&gt;北京&lt;/option&gt; &lt;option value="2"&gt;上海&lt;/option&gt; &lt;option value="3"&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;个人描述&lt;/label&gt; &lt;textarea name="info"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type="submit" name="" value="提交"&gt; &lt;input type="reset" name="" value="重置"&gt; &lt;input type="button" name="" value="单纯的按钮"&gt; &lt;input type="hidden" name=""&gt;&lt;/form&gt;&lt;h1&gt;11.全局属性和其他&lt;/h1&gt;1. 实体：将有特殊意义的字符通过实体代码显示出来 &lt;br&gt;显示括号： &amp;lt;div&amp;gt; &amp;lt;music&amp;gt; &lt;br&gt;空格： 我&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 你&lt;br&gt;和号： &amp;amp;HTML&lt;br&gt;引号： &amp;quot;HTML&lt;br&gt;撇号：&amp;apos;HTML&lt;br&gt;版权：&amp;copy;&lt;br&gt;2.元数据meta: &lt;br&gt;2.1. 指定名/值元数据对 &lt;br&gt;&amp;lt;meta name="author" content="bnbbs"&amp;gt;&lt;br&gt;&amp;lt;meta name="description" content="这是一个HTML页面"&amp;gt;&lt;br&gt;&amp;lt;meta name="keywords" content="html5响应"&amp;gt;&lt;br&gt;&amp;lt;meta name="generator" content="text3"&amp;gt;&lt;br&gt;2.2.声明编码格式&lt;br&gt;&amp;lt;meta charset="utf-8"&amp;gt;&lt;br&gt;3.全局属性: &lt;br&gt;3.1. id属性: &lt;br&gt;&amp;lt;p id="abc"&amp;gt;&lt;br&gt;&amp;lt;p id="def"&amp;gt;&lt;br&gt;id属性给元素分配一个唯一的标识符，通常用于CSS和javascript调用选中元素，只能是独有的&lt;br&gt;3.2. class属性: &lt;br&gt;&amp;lt;p class="abc"&amp;gt;&lt;br&gt;&amp;lt;p class="abc"&amp;gt;&lt;br&gt;&amp;lt;p class="abc"&amp;gt;&lt;br&gt;class也是用于定位，是用于元素的归类，通过CSS同时设置多个元素&lt;br&gt;3.3.accesskey元素: &lt;br&gt;&amp;lt;input type="text" name="user" accesskey="n&amp;gt;&lt;br&gt;快捷键操作，window下为Alt+指定的键&lt;br&gt;3.4.contenteditable属性:&lt;br&gt;&amp;lt;p contenteditable="true"&amp;gt;&lt;br&gt;用以修改text&lt;br&gt;3.5. dir属性： &lt;br&gt;&amp;lt;p dir="rtl"&amp;gt;&lt;br&gt;设置文本方向，左到右为ltr，右到左为rtl&lt;br&gt;3.6. hidden属性: &lt;br&gt;&amp;lt;p hidden&amp;gt;&lt;br&gt;隐藏元素&lt;br&gt;3.7. lang属性：&lt;br&gt;&amp;lt;p lang="en"&amp;gt;&lt;br&gt;可以局部设置语言&lt;br&gt;3.8. title属性：&lt;br&gt;&amp;lt;p title="HTML5教程"&amp;gt;&lt;br&gt;对元素的内容进行额外提示&lt;br&gt;3.9.tabindex元素 &lt;br&gt;&amp;lt;input type="text" name="user" tabindex="1"&amp;gt;&lt;br&gt;表单中按下Tab键，实现获取焦点的顺序，-1为不会被选中&lt;br&gt;3.10. style属性&lt;br&gt;&amp;lt;p style="color: red;"&amp;gt;&lt;br&gt;设置行内的CSS样式&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name = "1"&gt;&lt;/a&gt;这是第一章内容&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name = "2"&gt;&lt;/a&gt;这是第二章内容&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name = "3"&gt;&lt;/a&gt;这是第三章内容&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象编程]]></title>
    <url>%2F2019%2F03%2F04%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文主要的知识点是： java中类的定义 this和static的用法 封装的含义 重载的含义 1. Java的面向对象方法 继承 多态 封装 this的用法 引用隐式参数 调用该类的其他构造器 super的用法 调用超类方法 调用超类的构造器 1.1. 创建类和对象的方法对象和引用的一个关系图： 1.2. 定义class的模板1234567891011class ClassName &#123; field1 // 属性： 描述类的状态 field2 ... constructor1 constructor2 ... method1 // 方法： 描述类的行为 method2&#125; 1.3. 定义实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Main &#123; public static void main(String[] args) throws IOException &#123; // 对象的使用方法 // 对象.变量： staff.name // 对象.函数（）： staff.getname() Employee[] staff = new Employee[3]; staff[0] = new Employee("Zhang", 75000, 1977, 12,15); staff[1] = new Employee("Li", 23000, 1932, 3,5); staff[2] = new Employee("Zhang", 56444, 1964, 6,21); for (Employee e: staff)&#123; e.raiseSalary(5); &#125; for (Employee e: staff)&#123; System.out.println("name=" + e.getName() + ", salary=" + e.getSalary() + ", hireday=" + e.getHireDay()); &#125; &#125;&#125;// 一个类可以有无限多个对象class Employee&#123; // 三个实例域用来存放将要操作的数据 private String name; private double salary; private LocalDate hireDay; // 构造器（与类名同名），总是伴随着new操作符的执行而被调用 // 每个类可以有一个以上的构造器 // 如果类中没有构造器，java会默认有一个构造器用于初始化 // 但是如果类的构造器大于1个的话，需要自己构造默认构造器 // 构造器可以有0,1，...等多个参数 // 构造器没有返回值，即没有void // 构造器总是伴随着new的操作一起调用 public Employee(String n, double s, int year, int month, int day)&#123; name = n; salary = s; hireDay = LocalDate.of(year, month, day); &#125; // 需要获得或者设置实例域的值，需要提供以下三个内容： // (1).一个私有的数据域 // (2).一个公有的域访问器方法 // (3).一个公有的域更改器方法 public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void setHireDay(LocalDate hireDay) &#123; this.hireDay = hireDay; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; // class方法有两个参数： 显示参数(括号内部的参数) + 隐式参数(引用该方法的对象) // 用this来表示隐式参数，表示使用该方法的对象 public void raiseSalary(double rate)&#123; // 可以直接访问类的属性 double raise = this.salary * rate / 100; this.salary = this.salary + raise; &#125;&#125; 2. Java构造器构造器的注意事项 构造器与类同名 每个类可以有一个以上的构造器 构造器没有返回值 构造类的对象时，构造器会自动运行来初始化类 伴随着new而调用，跟方法不同 1Employee a1 = new Employee("hao"); 2.1. 隐式参数和显式参数方法用于操纵对象以及存取它们的实例域 12a1.raiseSalary(10);// 隐式参数.raiseSalary(显式参数) 关键字this用于代表隐式参数 1234public void raiseSalary(double byPercent)&#123; double raise = this.salary * byPercent / 100; this.salary += raise;&#125; 2.2. 封装的优点在定义一个类的时候，需要提供以下三个内容： 一个私有的数据域； 一个公有的域访问器方法； 一个公有的域更改器方法； 封装的优点如下： 保护数据不给外界破坏 检查输入数据 2.3. final实例域12private final String name;// 一旦建立，不可更改 3. 静态域和静态方法3.1. 静态成员变量静态成员变量的特点： 可以直接通过类名调用 类的对象共用一个静态变量(任何一个对象修改这个变量，所有的静态变量都变了) 理解为类级别的变量 3.2. 静态函数 也可以直接通过类名调用 静态函数中不能使用非静态变量 3.3. 静态代码块在装载类的时候执行,为了静态变量赋予初始值 3.4. main方法main方法也是一个静态方法，其不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象. 实例演示12345678910111213141516171819202122232425262728293031323334353637class Person&#123; // 静态变量 static int i; String name; // 静态函数 static fun()&#123; // System.out.println("我是静态函数" + this.name); 这是错误的 // 静态函数中不能使用非静态变量,如果这是this的话，这个this该如何解释，但是静态函数 // 是直接通过类名调用的，而不是对象调用. System.out.println("我是静态函数"); &#125; // 静态代码块 static&#123; System.out.println("我是静态代码块"); &#125; &#125;class Test&#123; public static void main(String args[])&#123; Person p1 = new Person(); Person p2 = new Person(); Person.i = 10; System.out.println("p1的i值是" + p1.i); System.out.println("p2的i值是" + p2.i); Person.fun(); &#125;&#125;// 结果为// p1的i值是: 10// p2的i值是: 10 4. 函数重载和this关键字4.1. 重载在一个类中允许函数重名的现象 两个或者多个函数在同一个类中 函数名相同 参数列表不同 123456789101112131415class A&#123; void funA()&#123; System.out.println("无参数的funA"); &#125; void funA(int i)&#123; System.out.println("有参数的funA"); &#125;&#125;A a = new A();a.funA(); // 无参数的funAa.funA(10); //有参数的funA 重载在构造函数中的使用,构造函数的特点： 没有返回值的定义 和类名一样 如果类中没有构造函数，编译器会自动添加一个空的构造函数 如果类中已经有了构造函数了，编译器就不会再添加一个无参数的构造函数 作用是为类赋予初始值 构造函数也可以重载 12345678910111213141516class A&#123; String name; int age; A()&#123; &#125; A(String name, int age)&#123; this.name = name; this.age = age; &#125; &#125; 4.2. this的使用 代表调用这个方法(函数)的对象 代表类中的成员变量 调用本类中的另外一个构造函数 12345678910111213141516171819202122232425262728293031323334353637383940class Person&#123; String name; String age; // this 在构造函数的用法 Person()&#123; System.out.println("无参数构造 "); &#125; Person(String name)&#123; this.name = name; &#125; Person(String name, String age)&#123; this(name); this.age = age; &#125; void talk()&#123; // this在方法中的用法 System.out.println("My name is " + this.name); &#125;&#125;class Test&#123; public static void main(String args[])&#123; Person p1 = new Person(); p1.name = "zhangsan"; Person p2 = new Person(); p2.name = "lisi"; p1.talk(); p2.talk(); &#125;&#125;// 结果为 // my name is zhangsan// my name is lisi]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法知识点]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发路线图]]></title>
    <url>%2F2019%2F03%2F03%2FAndroid%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密测试]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[密码为“你好”的拼音 Incorrect Password! No content to display! U2FsdGVkX1+W8rAzNGhwa984opPrMWSuKlpTGzSAYV0E2rdOUK/4N57OEICP2PntmXZ8g97gir+hyBGgIjUzD6RstAKbDt+VQaN2eYtDhsgmThK5B7FsQufZvCH0zAwWlF4MUMmQ08H5O2B1iwbqVOTxdBb20prCZmMyxDmX84Q5/im1JcXhZoYtf2Uq1wn6kotluqMGHF5Y72BQ7AxAADxPF7O1hq24r7SKtkXqYIG7mukYJS7tEyIT1Jd3mOBczVMUhAqzf1nyyj7zrqLy+wQwIz2bwbUeIqPqN3hMEUe2KS330KQgbsOZjsuRbw9DIVwAZRtcs8J1vttqDRos4Q==]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式语法以及re模块的使用]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8Are%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.正则表达式简介正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言，你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE以各种方式来修改或分割字符串。 2.正则表达式的语法简介 3.re模块的介绍3.1.re模块的核心函数和方法通过 pattern object 的方法（除 findall 外）进行匹配得到的返回结果都是 match object。每一个 match object 都包含了匹配到的相关信息，比如，起始位置、匹配到的子串。那么，我们如何从 match object 中提取这些信息呢？ 函数 描述 re.compile(pattern,flags=0) 将一个字符串通过指定的匹配模式flag编译成 pattern object，用于匹配或搜索 pattern.match(string[, pos[, endpos]]) 匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None pattern.search(string[, pos[, endpos]]) 扫描整个字符串，并返回它找到的第一个匹配（Match object） pattern.findall(string[, pos[, endpos]]) 找到所有匹配的子串，并返回一个 list pattern.finditer(string[, pos[, endpos]]) 找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器 pattern.split(rules,string,max=0) 根据正则表达式的rules，将字符串string分割成列表并返回 pattern.sub(rules,repl,string,count=0) 根据正则表达式rules匹配的结果将它替换为repl的形式，除非定义count，否则替换所有 pattern.purge() 清除所有的正则表达式 match.group([group1, …]) 返回 match object 中的字符串。 每一个 ( ) 都是一个分组，分组编号从1开始 match.groups(default=none) 返回由所有分组匹配到的字符串组成的 tuple。 match.groupdict(default=None) 返回一个包含所有匹配的命名子组的字典，子组名称为键 match.start([group]) 没有参数时，返回匹配到的字符串的起始位置,指定参数（整数）时，返回该分组匹配到的字符串的起始位置。。 match.end([group]) 没有参数时，返回匹配到的字符串的结束位置。 指定参数（整数）时，返回该分组匹配到的字符串的结束位置。 match.span 返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)。 re.I 不区分大小写的匹配 re.L 使用预定字符类\w\W\b\B\s\Sq取决于当前区域设定 re.M 多行模式 re.S 使得句号匹配除换行符外的所有单个字符 \ 转义符号 4. Python中的范例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import re# regex.match(string[, pos[, endpos]])# 匹配从 pos 到 endpos 的字符子串的开头。匹配成功返回一个 match object，不匹配返回 None。print("\n-------match的用法--------\n")p1 = re.compile(r'ar&#123;1&#125;')print("当不指定位置时,match只从开头匹配:匹配成功 ",p1.match("army"))print("当不指定位置时,match只从开头匹配:匹配失败 ",p1.match("akarmy"))print("match从指定位置的开头匹配:匹配成功 ",p1.match("akarmy",2))# regex.search(string[, pos[, endpos]])# 扫描整个字符串，并返回它找到的第一个匹配（Match object）。print("\n-------search的用法--------\n")print("search用法：匹配成功 ",p1.search("akarmy"))# regex.findall(string[, pos[, endpos]])# 找到所有匹配的子串，并返回一个 list 。print("\n-------findall的用法--------\n")p2 = re.compile(r"\d+")print("从字符串中找到所有数字",p2.findall("abc1def2rst3xyz"))# regex.finditer(string[, pos[, endpos]])# 找到所有匹配的子串，并返回由这些匹配结果（match object）组成的迭代器 。print("\n-------finditer的用法--------\n")for i in p2.findall("abc1def6rst25xyz"): print(i)# re.split(pattern, string, maxsplit=0, flags=0) 模块级函数print("\n-------split的用法--------\n")p2_1 = re.compile(r"[A-Z]+")print("根据大写字母分割字符串",p2_1.split("abcDefgHijkLmnoPqrs"))# re.sub(pattern, repl, string, count=0, flags=0)：# 替换函数print("\n-------sub的用法--------\n")def fun(m): return m.group().upper()pattern = re.compile(r"like", re.I)s1 = pattern.sub(r"love", "I like you, do you like me?")s2 = pattern.sub(fun, "I like you, do you like me?")print("love替换为like",s1)print("替换函数的使用",s2)# match.group([group1, ...])# 返回 match object 中的字符串。每一个 ( ) 都是一个分组，分组编号从1开始print("\n-------match.group的用法--------\n")p3 = re.compile(r"(\w+) (\w+)")m = p3.match("Kobe Bryant, Lakers")print("match object", m)print("完整匹配",m.group())print("match first group", m.group(1))print("match second group", m.group(2))# match.groups()# 返回由所有分组匹配到的字符串组成的 tupleprint("\n-------match.group的用法--------\n")print("match all the groups",m.groups())# match.start([group])# 没有参数时，返回匹配到的字符串的起始位置。指定参数（整数）时，返回该分组匹配到的字符串的起始位置。print("\n-------match.start的用法--------\n")print("返回第一个匹配开始的index值",m.start())print("返回第二组匹配开始的index值",m.start(2))# match.span([group])# 返回一个二元 tuple 表示匹配到的字符串的范围，即 (start, end)print("\n-------match.span的用法--------\n")print("返回第一个匹配的index范围值",m.span())print("返回第二个匹配的index范围值",m.span(2))# flags匹配模式的使用a = re.compile(r"like",re.I)print("忽略大小写的匹配",a.findall("I like you, do you LIKE me,or LiKes?")) 其输出结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-------match的用法--------当不指定位置时,match只从开头匹配:匹配成功 &lt;re.Match object; span=(0, 2), match=&apos;ar&apos;&gt;当不指定位置时,match只从开头匹配:匹配失败 Nonematch从指定位置的开头匹配:匹配成功 &lt;re.Match object; span=(2, 4), match=&apos;ar&apos;&gt;-------search的用法--------search用法：匹配成功 &lt;re.Match object; span=(2, 4), match=&apos;ar&apos;&gt;-------findall的用法--------从字符串中找到所有数字 [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]-------finditer的用法--------1625-------split的用法--------根据大写字母分割字符串 [&apos;abc&apos;, &apos;efg&apos;, &apos;ijk&apos;, &apos;mno&apos;, &apos;qrs&apos;]-------sub的用法--------love替换为like I love you, do you love me?替换函数的使用 I LIKE you, do you LIKE me?-------match.group的用法--------match object &lt;re.Match object; span=(0, 11), match=&apos;Kobe Bryant&apos;&gt;完整匹配 Kobe Bryantmatch first group Kobematch second group Bryant-------match.group的用法--------match all the groups (&apos;Kobe&apos;, &apos;Bryant&apos;)-------match.start的用法--------返回第一个匹配开始的index值 0返回第二组匹配开始的index值 5-------match.span的用法--------返回第一个匹配的index范围值 (0, 11)返回第二个匹配的index范围值 (5, 11)忽略大小写的匹配 [&apos;like&apos;, &apos;LIKE&apos;, &apos;LiKe&apos;] 参考资料如下： https://blog.csdn.net/lisonglisonglisong/article/details/39697137 https://www.cnblogs.com/haochen273/p/10256418.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8Are%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8]]></content>
      <categories>
        <category>Python核心编程</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP套接字介绍及Socket模块的使用]]></title>
    <url>%2F2019%2F03%2F02%2FTCP%E5%92%8CUDP%E5%A5%97%E6%8E%A5%E5%AD%97%E4%BB%8B%E7%BB%8D%E5%8F%8ASocket%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.客户端/服务端架构 服务端的作用: 等待客户端的请求，并相应他们提供服务，然后等待更多请求 客户端的作用： 发送请给给服务端以获取相关信息 注意： 客户端和服务器交互之前，需要进行一些必要的设置： 设置通信端点(比如，你要上网，必须要网线插口才可以) 客户端需要做的就是创建一个它的单一通信端点，然后建立一个到服务器的连接，然后，客户端就可以发送请求，一旦请求诶服务器处理，且客户端收到了请求的结果，此次通信就结束了 2. 套接字3. Python中的网络编程socket3.1. socket()模块函数创建套接字的语法如下： 1socket.socket(socket_family, socket_type, protocol=0) socket_family： 是AF_UNIX(基于文件的套接字)和AF_INET(基于网络的套接字) socket_type: SOCK_STREAM(面向连接的套接字，也称为TCP/TP套接字) + SOCK_DGRAM(无连接套接字，也称为UDP/TP套接字) protocol：一般为0，不用设置这个 123from socket import *tcpSock = socket(socket.AF_INET,socket.SOCK_STREAM) # 创建TCP/TP套接字udpSock = socket(socket.AF_INET,socket.SOCK_DGRAM) # 创建UDP/IP套接字 3.2. 套接字对象的方法 名称 说明 类别 s.bind() 将地址(主机名-端口号对)绑定到套接字上 服务器套接字方法 s.listen() 设置并启动TCP监听器 s.accept() 被动接受TCP客户端连接，一直等待直到连接到达(阻塞) s.connect() 主动发起TCP服务器连接 客户端套接字方法 s.connect_ex() connect的扩展，会以错误码的形式返回问题 s.recv() 接收TCP信息 普通的套接字方法 s.recv_into() 接收TCP信息到指定发缓存区 s.send() 发送TCP信息 s.sendall() 完整地发送TCP信息 s.recvfrom() 接收UDP信息 s.recvfrom_into() 接收UDP信息到指定的缓冲区 s.sendto() 发送UDP信息 s.getpeername() 连接到套接字TCP的远程地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回给定套接字选项的值 s.setsockopt() 设置给定套接字选项的值 s.shutdown() 关闭连接 s.close() 关闭套接字 s.detach() 在未关闭文件描述符的情况下关闭套接字，返回文件描述符 s.ioctl() 控制套接字的模式 s.setblocking() 设置套接字的阻塞或者非阻塞模式 面向阻塞的套接字方法 s.settimeout() 设置阻塞套接字的操作的超时时间 s.gettimeout() 获取阻塞套接字操作的超时时间 s.fileno() 套接字的文件描述符 面向文件的套接字方法 s.makefile() 创建与套接字关联的文件对象 s.family 套接字家族 数据类型 s.type 套接字类型 s.proto 套接字协议 3.3. 创建TCP服务器这里我给出了创建TCP服务器的一般流程 123456789ss = socket() # 创建服务器套接字ss.bind() # 套接字与地址绑定ss.listen() # 监听连接inf_loop: # 服务器无线循环中 cs = ss.accept() # 接收客户端连接 comm_loop: # 通信循环 cs.recv/cs.send() # 对话：接收或者发送 cs.close() # 关闭客户端套接字ss.close() # 关闭服务端套接字(可选) 所有套接字都需要通过socket.socket()来创建来占用一个端口bind()并等待客户端的请求 因为TCP是面向连接的通信，在执行请求前，需要设置一些监听设备listen()，一旦完成，就开始服务器的无线循环inf_loop 一旦服务器接收accpet()了一个连接，就会返回一个独立的客户端套接字cs，用它来与即将到来的信息进行交换(类似于主线员将这个客户切换给一个专用的客服代表，这样主线员就可以空出来继续接收连接) 通信开始，执行相关操作cs.recv或者cs.send() 完成通信，关闭客户端套接字(切断客服代表的电话)cs.close() 123456789101112131415161718192021222324252627282930from socket import *from time import ctimeimport threadingHOST = ''PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)tcpSerSock = socket(AF_INET,SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print("等待连接中....") tcpCliSock, addr = tcpSerSock.accept() print("获取了一个的连接: ",addr) while True: data = tcpCliSock.recv(BUFSIZ) SendText = 'Thanks for your connections---' + data.decode() print(type(data)) if not data: break tcpCliSock.send(SendText.encode()) tcpCliSock.close()tcpSerSock.close() 3.4. 创建TCP客户端这里我们给出创建TCP客户端的模板 12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话发送，接收cs.close() # 关闭客户端套接字 标准的TCP实例如下 123456789101112131415161718192021from socket import *HOST = 'localhost'PORT = 1565BUFSIZ = 1024ADDR = (HOST,PORT)tcpCliSock = socket(AF_INET,SOCK_STREAM)tcpCliSock.bind(ADDR)while True: data = input('&gt;') if not data: break tcpCliSock.send(data.encode()) data = tcpCliSock.recv(BUFSIZ) if not data: # 服务器端终止且对recv()方法的调用失败 break print(data.decode('utf-8'))tcpCliSock.close() 3.5. 运行TCP服务-客户端 首先运行TCP服务端 然后运行TCP客户端，并且输入Python 3.6. 创建UDP服务器UDP服务器不像TCP服务器那么多设置，因为UDP服务器不是面向连接的，除了等待传入的连接外，几乎不需要做其他任何工作 1234ss = socket()ss.bind()inf_loop: cs = css.recvfrom()/ss.sendto() 特点：服务器只接受小象，并可能回复数据 1234567891011121314151617181920from socket import *HOST = ''PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)udpServer = socket(AF_INET,SOCK_DGRAM)udpServer.bind(ADDR)while True: print("等待连接....") data,addr = udpServer.recvfrom(BUFSIZ) print("获取了一个的连接: ", addr) SendText = 'Thanks for your connections---' + data.decode() udpServer.sendto(SendText.encode(),addr)udpServer.close() 3.7. 创建UDP客户端12345678910111213141516171819202122from socket import *HOST = 'localhost'PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)udpCliSock = socket(AF_INET,SOCK_DGRAM)while True: into = input("&gt;") if not into: break udpCliSock.sendto(into.encode(),ADDR) data,ADDR = udpCliSock.recvfrom(BUFSIZ) if not data: break print(data.decode('utf-8'))udpCliSock.close() 运行服务端，以及客户端 参考文献 https://www.cnblogs.com/liu-yao/p/5283379.html]]></content>
      <categories>
        <category>Python网络编程</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中SocketServer的使用]]></title>
    <url>%2F2019%2F03%2F02%2FPython%E4%B8%ADSocketServer%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SocketServer模块介绍 SockerServer是创建网络客户端和服务器所必须的代码，这个模块有为你创建的各种各样的类 类 描述 BaseServer 包含服务器的核心功能 TCPServer/UDPServer 基于网络的TCP/UDP服务器 UnixStreamServer/UnixDatagramServer 基于文件的基础同步TCP/UDP服务器 ForkingMixIn/ThreadingMixIn 核心派出或者线程功能 ForkingTCPServer/ForkingUDPServer ForkingMixIn和TCPServer/UDPServer的组合 ThreadingTCPServer/ThreadingUDPserver ThreadingMixIn和TCPServer/UDPServer的组合 BaseRequestHandler 包含处理服务请求的核心功能 StreamRequestHandler/DatagramRequestHandler 实现TCP/UDP服务器的服务处理器 2. 创建SocketServer TCP服务器12345678910111213141516171819202122from socketserver import (TCPServer as TCP, StreamRequestHandler as SRH)HOST = ''PORT = 21567ADDR = (HOST,PORT)class MyRequestHandler(SRH): # 重写SRH中的handle方法 # 当接收一个来自客户端的信息时，他就会调用handle()方法 def handle(self): print("获取了一个的连接: ", self.client_address) # SRH将输入和输出套接字看成类似文件的对象，我们可以通过readline()来获取客户端信息，并通过write()将字符串发送给客户端 SendText = 'Thanks for your connections---' + self.rfile.readline() self.wfile.write(SendText)tcpServ = TCP(ADDR,MyRequestHandler)print("等待连接.....")# 无线循环下去tcpServ.serve_forever() 3. 创建SocketServer TCP客户端12345678910111213141516171819202122from socket import *HOST = 'localhost'PORT = 21567BUFSIZ = 1024ADDR = (HOST,PORT)while True: # socketserver的默认行为：接收连接、获取请求、关闭连接 # 我们不能再整个应用执行过程中一直保持连接，每次向服务器发送消息时，都需要创建一个新的套接字 tcpClient = socket(AF_INET, SOCK_STREAM) tcpClient.connect(ADDR) into = input("&gt;") if not into: break tcpClient.send(into.encode()) data = tcpClient.recv(BUFSIZ) if not data: break print(data.strip()) tcpClient.close()]]></content>
      <categories>
        <category>Python网络编程</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts的API配置内容]]></title>
    <url>%2F2019%2F03%2F02%2Fpyecharts%E7%9A%84API%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[基本用法安装pyecharts 1pip install pyecharts 图表配置图形初始化选项 接收参数 默认值 说明 title(str) “” 主标题 subtitle(str) “” 副标题 width(int) 800px 画布宽度 height(int) 400px 画布高度 title_pos(str/int) left 标题距离左侧距离 title_top(str/int) top 标题距离顶部距离 title_color(str) #000 主标题颜色 subtitle_color(str) #aaa 副标题颜色 title_text_size(int) 18 主标题字体大小 subtitle_text_size (int) 12 副标题字体大小 background_color(str) ‘#fff’ 画布背景颜色 page_title (str) ‘Echarts’ 指定生成的 html 文件中 &lt;title&gt; 标签的值 renderer(str) ‘canvas’ 指定使用渲染方式 extra_html_text_label(list) is_animation(bool) True 是否开启动画 通用配置项：add()中设置xyAxis：轴相关设置 设置选项 格式 说明 is_convert bool 是否交换 x 轴与 y 轴 is_xaxislabel_align bool x 轴刻度线和标签是否对齐 is_xaxis_inverse bool 是否反向 x 坐标轴。 is_xaxis_boundarygap bool x 轴两边留白策略，适用于类目轴。 is_xaxis_show bool 是否显示 x 轴 is_splitline_show bool 是否显示 y 轴网格线。 x_axis list x 轴数据项 xaxis_interval int x 轴刻度标签的显示间隔，在类目轴中有效。 xaxis_margin int x 轴刻度标签与轴线之间的距离 xaxis_name string x 轴名称 xaxis_name_size int x 轴名称体大小 xaxis_name_gap in x 轴名称与轴线之间的距离。 xaxis_name_pos str x 轴名称位置，有’start’，’middle’，’end’可选 xaxis_min int/float x 坐标轴刻度最小值，默认为自适应。 xaxis_max int/float x 坐标轴刻度最大值，默认为自适应。 xaxis_pos str x 坐标轴位置，有’top’,’bottom’可选 xaxis_label_textsize int x 坐标轴标签字体大小。 xaxis_label_textcolor str x 坐标轴标签字体颜色。 xaxis_type str x 坐标轴类型（value,category,log） xaxis_rotate int x 轴刻度标签旋转的角度 xaxis_formatter str x 轴标签格式器（回调函数） xaxis_line_color str x 坐标轴线线的颜色。 xaxis_line_width int x 坐标轴线线的宽度。 datazoom：缩放设置一般不用，详情请看http://pyecharts.org/#/zh-cn/charts_configure legend:图例组件 设置选项 格式 说明 is_legend_show bool 是否显示顶端图例 legend_orient str 图例列表的布局朝向 legend_pos str 图例组件离容器左侧的距离’left’, ‘center’, ‘right’ legend_top str 图例组件离容器上侧的距离 legend_selectedmode str/bool 图例选择的模式，控制是否可以通过点击图例改变系列的显示状态 legend_text_size int 图例名称字体大小 legend_text_color str 图例名称字体颜色 label:文本标签 设置选项 格式 说明 is_label_show 是否正常显示标签 is_label_emphasis 是否高亮显示标签 label_pos 标签的位置’top’, ‘left’, ‘right’, ‘bottom’, ‘inside’,’outside’ label_emphasis_pos 高亮标签的位置’top’, ‘left’, ‘right’, ‘bottom’, ‘inside’,’outside’ label_text_color 标签字体颜色 label_emphasis_textcolor 高亮标签字体颜色 label_text_size 标签字体大小 label_emphasis_textsize 高亮标签字体大小 is_random 是否随机排列颜色列表 label_color 自定义标签颜色 label_formatter toolbox 设置选项 格式 说明 is_toolbox_show bool 是否显示右侧实用工具箱 is_more_utils bool 指定是否提供更多的实用工具按钮]]></content>
      <categories>
        <category>Python可视化</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础语法]]></title>
    <url>%2F2019%2F03%2F02%2FMySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本MySQL语法从CMD中调用mysql运行以下代码mysql -u root -p连接服务器并且输入密码 创建数据库 语法 用法说明 create database 数据库名字 charset=utf8; 创建数据库 drop database 数据库名字; 删除数据库 use 数据库名字; 使用这个数据库 show databases; 查看当前的所有数据库 select database(); 查看当前正在用的是哪个数据库 创建数据库下面的表 语法 用法说明 show tables; 查看所有的表 create table 表名(列和其类型); 创建表 desc 表名; 查看表的结构 `alter table 表名 add change drop 列名 类型；` 修改表(增加，修改，删除列) drop table 表名; 删除表 rename table 原表名 to 新表名; 更改表的名字 show create table 表名; 查看表的创建语句 表格中的数据操作 语法 用法说明 select * from 表名; 查询数据 insert into 表名 values(…); 添加数据（顺序要与表格一致）:全列插入 insert into 表名(列1，..，) values(…); 添加数据（顺序要与表格一致）:指定列插入 insert into 表名 values(),()…; 添加数据：一次性插入多条数据 update 表名 set 列1=值1,… where 条件; 修改数据 delete from 表名 where 条件; 删除数据 例子演示123456789101112131415161718create table students( id int auto_increment primary key not null, name varchar(10) not null, gender bit default 1, birthday datetime ) alter table students add isDelete bit default 0;desc students; show create table students; insert into students values(0, &apos;hao&apos;,1,&apos;1991-1-1&apos;,0);insert into students(name) values(&apos;a1&apos;),(&apos;a2&apos;),(&apos;a3&apos;);update students set birthday=&apos;1990-2-5&apos; where id=2;select * from students; 123456789101112131415161718192021222324252627+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || gender | bit(1) | YES | | b&apos;1&apos; | || birthday | datetime | YES | | NULL | || isDelete | bit(1) | YES | | b&apos;0&apos; | |+----------+-------------+------+-----+---------+----------------+ | students | CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) NOT NULL, `gender` bit(1) DEFAULT b&apos;1&apos;, `birthday` datetime DEFAULT NULL, `isDelete` bit(1) DEFAULT b&apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 | +----+------+--------+---------------------+----------+| id | name | gender | birthday | isDelete |+----+------+--------+---------------------+----------+| 1 | hao |  | 1991-01-01 00:00:00 | || 2 | hao |  | 1991-01-01 00:00:00 | || 3 | kjkj |  | NULL | | MySQL查询语句查询的基本语法是 1234select * from students; # 全部查询select id,name from students; # 根据条件选择select distinct gender from students; # 消除重复行select distinct id, gender from students; # 消除重复行(id, gender全部相同时才会消除) 条件where对行数据进行筛选，满足要求的出现在结果集中，不满足的直接舍弃不要 先查看condition，在执行select 1select * from 表名 wehre conditions; condition的写法 比较运算符： =, &gt;, &lt;, &gt;=,&lt;=, != 1select * from students where id&gt;3; 逻辑运算符： and, or, not 1select * from students where id&gt;3 and gender=0; 模糊查询： 关键字： like %表示任意多个字符 _表示任意一个字符例子：查询姓黄的学生 1select * from students where name like &apos;黄%&apos;; 例子：查询黄（两个字）的学生 1select * from students where name like &apos;黄_&apos;; 例子：查询名字中间有财的的学生 1select * from students where name like &apos;%财%&apos;; 范围查询 12select * from students where id in (1,3,8);select * from students where id between 3 and 8; 空判断 12select * from students where birthday is null;select * from students where birthday is not null;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的基本语法及在python中的实现]]></title>
    <url>%2F2019%2F03%2F02%2FMySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%9C%A8python%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文的主要目的是： 通过一个例子全方位了解mysql的基础以及深度使用语法 建立一个students表格,查询等操作和scores,subject关联，聚合操作 python和mysql的交互操作 和students表格交互 更高效的python-mysql语法 代码封装用户登录系统 使用到的包为： mysql, pymysql, hashlib 1. MySQL语法1.1. 创建students数据库1234567891011121314151617181920212223242526272829303132333435mysql -u root -p # 查看有多少数据库show databases;# 创建数据库create database practice charset='utf8'; # 删除数据库# drop database practice# 使用数据库use practice;# 创建tablecreate table students( id int primary key auto_increment not null, name varchar(10), birthday datetime, gender bit default 1);# 查看数据库下所有的tableshow tables; # 修改tablealter table students add isDelete bit default 0;# 删除表格# drop table practice# 查看table的结构desc table;# 查看创建table的语句show create table students; 12345678910111213141516171819202122232425262728293031323334353637+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || python3 || sakila || sys || world |+--------------------++----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | YES | | NULL | || birthday | datetime | YES | | NULL | || gender | bit(1) | YES | | b&apos;1&apos; | || isDelete | bit(1) | YES | | b&apos;0&apos; | |+----------+-------------+------+-----+---------+----------------++--------------------+| Tables_in_practice |+--------------------+| students |+--------------------+1 row in set (0.00 sec) students | CREATE TABLE `students` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) DEFAULT NULL, `birthday` datetime DEFAULT NULL, `gender` bit(1) DEFAULT b&apos;1&apos;, `isDelete` bit(1) DEFAULT b&apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 1.2. MySQL数据操作增加数据123456789# 方法 1： 直接插入insert into students values(1,'hao','1995-10-10',1,0);insert into students values(2,'li','2001-9-8',1,0);insert into students values(3,'wang','2015-2-15',0,0);# 方法2： 选择列 + 多数据同时插入insert into students(name) values('meng'),('bei');select * from students; 123456789+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 1 | hao | 1995-10-10 00:00:00 |  | || 2 | li | 2001-09-08 00:00:00 |  | || 3 | wang | 2015-02-15 00:00:00 | | || 4 | meng | NULL |  | || 5 | bei | NULL |  | |+----+------+---------------------+--------+----------+ 删除数据1234567891011delete from students where name = &quot;meng&quot;;+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 1 | hao | 1995-10-10 00:00:00 |  | || 2 | li | 2001-09-08 00:00:00 |  | || 3 | wang | 2015-02-15 00:00:00 | | || 5 | bei | NULL |  | |+----+------+---------------------+--------+----------+ 查询数据这部分单独拿出来讲 1.3. MySQL查询操作1.条件查询where1select * from 表名 wehre conditions; condition的写法 比较运算符： =, &gt;, &lt;, &gt;=,&lt;=, != 1select * from students where id&gt;3; 逻辑运算符： and, or, not 1select * from students where id&gt;3 and gender=0; 模糊查询： 关键字： like %表示任意多个字符 _表示任意一个字符例子：查询姓黄的学生 1select * from students where name like &apos;黄%&apos;; 例子：查询黄（两个字）的学生 1select * from students where name like &apos;黄_&apos;; 例子：查询名字中间有财的的学生 1select * from students where name like &apos;%财%&apos;; 范围查询 12select * from students where id in (1,3,8);select * from students where id between 3 and 8; 空判断 12select * from students where birthday is null;select * from students where birthday is not null; 2. 聚合为了快速得到统计数据，提供了5个聚合函数 12345select count(*) from students; # 统计有多少行select max(id) from students where gender=0; # 求最大值select min(id) from students where gender=0; # 求最大值select sum(id) from students where gender=0; # 求和select avg(id) from students where gender=0; # 求最大值 3.分组groupby 按照字段分组，表示此字段相同的数据会被放到一个组中（为了更好的统计数据） 分组后，只能查询相同的数据列，有差异的数据列无法显示在结果列中 语法是 1select 列1，列2，聚合... from 表名 group by 列1， 列2，列3... 12345678select gender ,count(*) from stundets group by gender; # 查询男女生总数 +--------+----------+| gender | count(*) |+--------+----------+|  | 3 || | 1 |+--------+----------+ 分组后筛选1select 列1，列2，聚合... from 表名 group by 列1， 列2，列3... having 列1...聚合.... 分组病筛选例子 12select gender ,count(*) from stundets group by gender having gender=0;select gender ,count(*) as rs from stundets group by gender having rs&gt;2; # rs为一个count()的标记名 where是对from后面指定的表进行数据筛选，属于原始数据的筛选 having是对group by的结果进行筛选 4.排序 asec升序排， desc降序排 1select * from 表名 order by 列1 asc |desc, 列2 asc |desc,... 排序例子1select * from students where isdelete=0 and gender=1 order by id desc; 1234567+----+------+---------------------+--------+----------+| id | name | birthday | gender | isDelete |+----+------+---------------------+--------+----------+| 5 | bei | NULL |  | || 2 | li | 2001-09-08 00:00:00 |  | || 1 | hao | 1995-10-10 00:00:00 |  | |+----+------+---------------------+--------+----------+ 5. 分页 limit 当数据量过大时，分页查看数据 1select * from 表名 limit start, count # 从start开始，获取count条数据 已知：每个显示m条数据，当前是第n页(n=1,…) 1select * from students where isdelete=0 limit (n-1)*m, m 6. 总结完整的查询语句 12345select * from tablewhere ...group by ... having....orderby ....limit start, count 1.2. MySQL关系操作1. 关系分析分析 分析： 一个成绩对应有多个科目，在成绩中创建外键引用 创建表的语句 12345create table scores( -&gt; id int primary key auto_increment not null, -&gt; stuid int, -&gt; subid int, -&gt; score decimal(4,1)); 2. 使用外键保证关系数据的有效性 必须是学生表中id列存在的数据，可以通过外键约束进行数据的有效性验证 123456789101112# 添加外键约束 alter table scores add constraint stu_sco foreign key(stuid) references student (id);# 或者直接在创建的时候添加约束 create table scores( id int primary key auto_increment not null, stuid int, subid int, score decimal(4,1), foreign key(stuid) references students (id), foreign key(subid) references subjects (id)); 只有stuid在students的id中才有效，同理subid 3. 连接join当我们查看scores表的时候呈现的结果是这样的 123456789mysql&gt; select * from scores;+----+-------+-------+-------+| id | stuid | subid | score |+----+-------+-------+-------+| 1 | 1 | 1 | 100.0 || 2 | 2 | 2 | 98.0 || 3 | 2 | 1 | 96.0 || 4 | 1 | 2 | 86.0 |+----+-------+-------+-------+ 但是这个表一点都不直观，我哪里知道stuid的1和2代表的谁啊？如果能够显示出人名就好啦，目标效果为 12 张山 数学 100students.name subjects.title scores.score 方法 1234select students.name,subjects.title,scores.score from scores inner join students on stuid = students.idinner join subjects on scores.subid = subjects.id; 1234567+------+---------+-------+| name | title | score |+------+---------+-------+| hao | math | 100.0 || hao | math | 96.0 || hao | english | 98.0 || hao | english | 86.0 | 结果来源于多张表的时候，使用连接查询 连接查询的种类 inner join： 内连接，要求连接的表都匹配的才会出现 left join： 左连接， 对应数据都有 + 左边表信息也会显示出现，内容为NULL right join： 右连接，上同 4. 自关联设计一个省的表结构provinces id ptitle设计一个市信息的表结构citys id ctitle proid（城市所属的省-id） 问题： 每次新建一张表的开销大，而且储存的内容很少—： 有没有可能将这两个表统一成一张表呢？ 答案：自关联： 表中的某一列，关联了这个表的另外一列 123456create table areas( id int primary key, atitle varchar(20), pid int, foreign key(pid) references areas(id) ); 导入外部sql文件 1source area.sql; 查询一共有多少省 1select count(*) from areas where pid is null 查询省的名称为“山西省”的所有城市 123select city.* from areas as cityinner join areas as province on city.pid=province.aidwhere province.atitle=&quot;山西省&quot;; 查询市的名称为“广东市”的所有区县 123select dis.* from aras as disinner join areas as city on city.aid = dis.prdwhere city.atitle = &quot;广州市&quot;; 5. 视图 对于复杂的查询，多次使用时，维护很麻烦 解决：定义视图——来代表复杂的查询 视图本身是对查询的一个封装 123456789# 创建viewcreate view myview asselect * from scoresinner join students on scores.stuid = students.idinner join subjects.on scores.subid = subjects.id;# 使用视图select * from myview; 6. 事务:git版本回退功能 当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，希望整个操作都退回 使用事务可以完成退回的功能，保证业务逻辑的正确性 事务的四大特征（ACID）: 原子性(Atomicity): 事务的全部操作在数据库中时不可分割的，要么全部完成，要么不执行 一致性(Consisitency)： 几个并行执行的事务，其执行结果必须与按照某一顺序串行执行的结果一致 隔离线(Isolation)： 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的 持久性(Durability)： 对于任意已经提交的事务，系统必须保证该事务对数据库的改变不被丢弃 要求：表的类型必须是innodb或者bdb类型才能使用事务 使用情况：当数据被更改时，insert, alter等 123456789# 查看表的创建语句show create table students;# 修改表的类型alter table 表名 engine=innodb;# 事务语句开启begin；提交commit；回滚rollback； 例子： 12345begin; # 开启数据update students set name = &apos;option&apos; where id=1; # 修改数据commit; # 提交修改rollback; # 修改被放弃了 2. Python和MySQL的交互安装mysql for python 1pip install PyMySQL 2.1 基本用法1. Connector对象 用于建立与数据库的连接 创建对象：调用connect()方法 1conn = connect(host主机, port端口, db数据库名称, user用户, password密码, charset) 对象的方法有 close()关闭 commit()提交事务 rollback()撤销操作 cursor()返回Cursor对象，用于执行sql语句并且获得结果 2. Cursor对象 执行sql语句 创建对象： 调用Connection对象的cursor()方法 1curxor1 = conn.cursor() 对象方法 close()： 关闭 execute(operation [, paramters])： 执行语句，返回受影响的行数 fetchone()： 执行查询语句时，获取查询结果集的第一行数据，返回一个元组 next()： 执行查询语句时，获取当前行的下一行 fetchall()： 执行查询时，获取结果期的所有行，一行构成一个元组 scroll(value, [mode]) 将行指针移动到某个位置 mode：移动的方式 mode：默认为relative，表示基于当前行移动到value，value为正则向下移动 mode的值Wieabsolute，表示基于第一条数据的位置(0) 对象的属性 rowcount：只读属性，表示最近一次exectute()返回的行数 connection: 获取当前的连接对象 2.2 增改删查12345678910111213141516171819202122232425262728293031from pymysql import *try: # 通过connect连接mysql数据库 conn = connect(host='localhost',port=3306,database='python3', user='root',password='720678',charset='utf8') # 获得Cursor对象 cursor1 = conn.cursor() # 增加数据 cursor1.execute('insert into students(name) values("飞机")') # 更新数据 cursor1.execute('update students set name="大炮" where name = "a1"') # 删除数据 cursor1.execute('delete from students where id = 10') # 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交 conn.commit() # 关闭Cursor对象 cursor1.close() # 关闭Connection对象 conn.close() print("MySQL operation works. Congrad...")except Exception: print("Wrong!!!!") 下面来看看怎么查看数据 1234567891011121314151617181920212223242526272829try: conn = connect(host='localhost',port=3306,database='python3', user='root',password='720678',charset='utf8') cursor1 = conn.cursor() # 查询数据 count = cursor1.execute('select id, name from students where id&gt;=5') # 打印受影响的行数 print("查询到%d条数据:" % count) for i in range(count): # 获取查询的结果 result = cursor1.fetchone() # 打印查询的结果 print(result) conn.commit() cursor1.close() conn.close() print("MySQL operation works. Congrad...")except Exception: print("Wrong!!!!") 2.3. 参数化 执行数据库中的内置函数，通过调用参数来查询 1234sname = input("请输入学生姓名：")params = [sname]count = cursor1.execute('insert into students(name) values(%s)', params) 2.4. 封装上述代码一看 就有重复性，我们可以将它封装到一个类中，实际应用中我们只关注他的sql语句的书写 (4.4) 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445import pymysqlclass MySQLHelper(): def __init__(self,host,port,db,user,passwd,charset = 'utf8'): self.host = host self.port = port self.database = db self.user = user self.password = passwd self.charset = charset def connect(self): self.conn = pymysql.connect(host = self.host, port = self.port, user = self.user, password = self.password, database = self.database, charset = self.charset) self.cursor = self.conn.cursor() def close(self): self.cursor.close() self.conn.close() def cud(self, sql, params): try: self.connect() self.cursor.execute(sql, params) self.conn.commit() self.close() except Exception: print("Wrong") def all(self, sql, params): try: self.connect() self.cursor.execute(sql, params) res = self.cursor.fetchall() self.close() return res except Exception: print("Wrong") 使用： 1234567891011from MySQL.MySQLHelper import MySQLHelpername = input("请输入学生姓名")nub = input("请输入学生编号")sql = 'update students set name = %s where id = %s'params = [name, nub]sqlhelper = MySQLHelper('localhost', 3306, 'python3', 'root', '720678')sqlhelper.cud(sql,params) 3. 实例：实现用户登录功能 接收用户输入： 用户名 + 密码 根据用户名，查询密码 未查到： 用户名错误 查到： 匹配密码 匹配失败： 错误 匹配成功： 登录成功 创建表 表的结构： id, uname, upwd, isdelete 需要对密码加密： md5加密：密码包含32个字符 sha1加密： 密码包含40个字符 12345678create table users( id int primary key auto_increment, name varchar(10), password char(40) );insert into users values(1,&apos;hao&apos;,&apos;1d2b703d7a1f59d7d04c1850a2e308810b49b851&apos;); # 密码是123 12345+----+------+------------------------------------------+| id | name | password |+----+------+------------------------------------------+| 1 | hao | 40bd001563085fc35165329ea1ff5c5ecbdbbeef |+----+------+------------------------------------------+ 写登录模块123456789101112131415161718192021from MySQL.MySQLHelper import MySQLHelperfrom hashlib import sha1name = input("请输入用户名： ")pwd = input("请输入密码： ")# 对密码加密s1 = sha1()s1.update(pwd.encode('utf-8'))pwd2 = s1.hexdigest()sql = 'select password from users where name = %s'helper = MySQLHelper('localhost', 3306, 'python3', 'root', '720678')result = helper.all(sql, [name])if len(result) == 0: print("用户名出错")elif result[0][0] == pwd2: print("登录成功")else: print("密码错误") 测试 123请输入用户名： hao请输入密码： 123登录成功 4. MySQL常用语法4.1.创建数据库 语法 用法说明 create database 数据库名字 charset=utf8; 创建数据库 drop database 数据库名字; 删除数据库 use 数据库名字; 使用这个数据库 show databases; 查看当前的所有数据库 select database(); 查看当前正在用的是哪个数据库 4.2.创建数据库下面的表 语法 用法说明 show tables; 查看所有的表 create table 表名(列和其类型); 创建表 desc 表名; 查看表的结构 `alter table 表名 add change drop 列名 类型；` 修改表(增加，修改，删除列) drop table 表名; 删除表 rename table 原表名 to 新表名; 更改表的名字 show create table 表名; 查看表的创建语句 4.3.表格中的数据操作 语法 用法说明 select * from 表名; 查询数据 insert into 表名 values(…); 添加数据（顺序要与表格一致）:全列插入 insert into 表名(列1，..，) values(…); 添加数据（顺序要与表格一致）:指定列插入 insert into 表名 values(),()…; 添加数据：一次性插入多条数据 update 表名 set 列1=值1,… where 条件; 修改数据 delete from 表名 where 条件; 删除数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB语法大全]]></title>
    <url>%2F2019%2F03%2F02%2FMongoDB%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1.MongoDB简介1.1.MongoDB特点 模式自由：可以将不同格式的文档存在同一个数据库中 面向集合的储存： 适合储存JSON风格文件的形式 完整的索引支持：对任何书写可索引 复制和高可用性： 支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制 自动分片： 支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器 丰富的查询： 支持丰富的查询表达方式 快速就地更新：查询优化器会分析查询表达式，并生成一个搞笑的额查询计划 搞笑的传统储存方法，支持二进制数据及大型对象，比如图片 1.2.MongoDB与MySQL的区别 MySQL术语 MongoDB术语 说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接，MongoDB不支持 primary key primary key 主见 1.3.MongoDB三元素 数据库 一个集合的物理容器，一个数据库中科院包含多个文档 文档： 就是SQL的行 一个对象，由键值对组成，是json的扩展 1&#123;&apos;name&apos;:&apos;guojing&apos;, &apos;gender&apos;:&apos;男&apos;&#125; 集合：就是SQL中的表 类似SQL中的表，储存多个文档，结构不固定： 123&#123;&apos;name&apos;:&apos;guojing&apos;, &apos;gender&apos;:&apos;男&apos;&#125;&#123;&apos;name&apos;:&apos;hua&apos;, &apos;age&apos;:20&#125;&#123;&apos;name&apos;:&apos;shxhx&apos;, &apos;hero&apos;:&apos;1998&apos;&#125; 1.4. window中启动mongodb的服务 首先在官网下载安装好数据库 将MongoDB添加到 环境变量 找到MongoDB的bin文件夹：C:\Program Files\MongoDB\Server\4.0\bin 打开计算机-属性-高级系统设置-环境变量-系统变量-path-编辑-粘贴上面的bin地址 在CMD中输入mongo就可以进入服务了 2. 数据库的语法2.1. 数据库语法 代码 说明 db 查看当前数据库 show dbs 查看所有数据库 use 数据库名字 使用数据库(没有的话自动创建) db.dropDatabase() 删除当前数据库 2.1. 集合语法 代码 说明 db.createCollection(集合名字，其他选项) 创建集合 show collections 查看当前数据库的集合 db.集合名字.drop() 删除一个集合 2.2. 支持的数据类型 类型 说明 ObjectID 文档ID：保证文档的唯一性 String 字符串 Boolean 布尔 Integer 整数 Double 浮点 Arrays 数组和列表 Object 嵌入式文档 NULL 存NULL值 Timestamp 时间戳 Date 存当前时间 12# capped是否设置集合大小的上限db.createCollection("sub", &#123;capped: true, size :10&#125;) # capped：true 如果db的容量大于10的话，就会覆盖 3. 数据库的实际操作3.1. 增修删1234567891011121314151617181920212223242526272829303132# 插入db.集合名称.insert(document)db.mask.insert(&#123;'name':'g', gender:1&#125;)# 更改db.集合名称.update( &lt;query&gt;, # 查询条件，类型where &lt;update&gt;, # 更新操作费，类型set &#123;multi:&lt;boolean&gt;&#125; # false：只更新找到的第一条记录,true:修改多行)db.mask.update(&#123;name:'hr'&#125;,&#123;name: 'ceo'&#125;) # 这个会修改整个文档结构，最后用set，只修改值db.mask.update(&#123;&#125;,&#123;$set:&#123;gender:0&#125;&#125;,&#123;multi:true&#125;) # 修改多个数据# 删除db.集合名称.remove( &lt;query&gt;, &#123; justOne:&lt;Boolean&gt; # TRUE：只删除一条，false：删除多条 &#125;)db.mask.remove(&#123;gender:0&#125;,&#123;justOne:true&#125;) # 只删除匹配的第一条db.mask.remove(&#123;&#125;) # 删除所有# 简单查询db.mask.find()# &#123; "_id" : ObjectId("5c6e7e90394099d27b230266"), "name" : "g", "gender" : 1 &#125; 3.2. 查询操作1.基本查询12345678# 基础查询db.集合名称.find(&#123;条件文档&#125;)# 查询只返回一个数据db.集合名称.findOne():# 查询结果格式化db.集合名称.find(&#123;条件文档&#125;).pretty() 1） 比较运算符 等于，直接用属性 + : 小于：$lt 小于等于:$lte 大于: $gt 大于等于: $gte 不等于: ne 1db.mask.find(&#123;count:&#123;$gt:5&#125;&#125;) # count大于5的结果 2）逻辑运算符 and： 不需要写什么，逗号就是了 or：使用$or and和or结合使用 123db.mask.find(&#123;age:&#123;$gte:18&#125;, gender:1&#125;)db.mask.find(&#123;$or:[&#123;age:&#123;$gte:18&#125;,gender:1&#125;]&#125;)db.mask.find(&#123;$or:[&#123;age:&#123;$gte:18&#125;,gender:1&#125;],name:'gj'&#125;) 3）范围运算符 使用$in,$nin判断是否在某个范围内 1db.mask.find(&#123;age:&#123;$in:[18,28]&#125;&#125;) # 年龄为18和28的学生 4）支持正则表达式 使用//或者$regex编写正则表达式 1db.mask.find(&#123;name:&#123;$regex:'^黄'&#125;&#125;) # 查询姓黄的学生 2. 自定义函数查询 使用$where定义函数查询 函数跟JS函数定义是一样的 1db.mask.find($where:function()&#123;return this.age&gt;20&#125;) 3.查询的扩展功能1）Limit + Skip limit：用于读取指定数量的文档，表示获取几条数据 skip: 跳过指定数量的文档，从第几条开始看 12db.mask.find().limit(2) # 只查询两条信息db.mask.find().skip(2) # 查询从第三条开始的信息 2）投影 在查询返回的结果中，只选择必要的字段，而不是选择一个文档的整个字段—-投影 在find的第二个参数中去写 123db.集合名称.find(&#123;&#125;,&#123;字段名称:1,...&#125;) # 需要显示的字段，设置为1db.mask.find(&#123;&#125;,&#123;_id:0, name:1,gender:1&#125;) 3）排序 sort方法 1db.mask.find().sort(&#123;age:-1&#125;) # 1为升序，-1为降序 3）统计个数 count()方法 123db.集合名称.count(&#123;条件&#125;)db.mask.count(&#123;age:&#123;gt:20&#125;&#125;) 3）消除重复 distinct() 去重复 123db.集合名称.distinct('去重字段'，&#123;条件&#125;)db.mask.distinct(gender,&#123;age:&#123;$gt:20&#125;&#125;) # age大于20的进行消除重复 4.MongoDB的高级操作主要讲解这个数据库的高级操作，包括聚合、主从复制、分片、备份和恢复、MR、与python的交互 4.1. 聚合aggregate 用于计算数据，类型sum()和avg（） 1db.集合名称.aggregate([&#123;管道:&#123;表达式&#125;&#125;]) 管道的含义： 将前一次操作的输出结果作为下一个命令的输入 常用管道有： $group:将集合中的文档分组，用于统计结果 $match:过滤数据，只输出符合条件的文档 $project:修改输入文档的结果 $sort:将输入文档排序后输出 $limit:限制聚合管道返回的文档数 $skip:跳过指定数量的文档 $unwind:将数组类型的字段进行拆分 表达式： 处理输入文档并输出 1表达式：'$列名' 常用表达式为： $sum: 计算总数 $avg: $min: $max: $push:在结果文档中插入值到另外一个数组中 $first:根据资源文档的排序获取第一个文档数据 $last:根据资源文档的排序获取最后一个文档数据4.1.1. $group 将集合中的文档分组，用于统计结果 _id表示分组的依据，使用某个字段的格式为’$字段’ 123456789# 统计男生，女生的总人数db.mask.aggregate([ &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125; &#123;$group:&#123;_id:'$gender',counter:&#123;$avg:'age'&#125;&#125;&#125; # gender分组，对age求和 &#123;$group:&#123;_id:'$gender',counter:&#123;$frist:'age'&#125;&#125;&#125; # 拿到第一个值 # push--透视数据 &#123;$group:&#123;_id:'$gender',counter:&#123;$push:'age'&#125;&#125;&#125; # 将基于gender的分组结果放到数组中 &#123;$group:&#123;_id:'$gender',counter:&#123;$push:'$$ROOT'&#125;&#125;&#125; # 查看文档所有内容(gender分组情况下) ]) Group by null 将这个集合数据分成一组 123db.mask.aggregate( &#123;$group:&#123;_id:null,counter:&#123;$sum:1&#125;&#125;&#125;) 4.1.2. $match 用于过滤数据 4.1.3.$project 将结果集中的一部分拿出来显示 4.1.4. $sort 用于排序 4.1.5. $limit+skip4.1.6. $unwind 将文档中的某个数组类型字段拆分成多条，每条包含数组中的一个值 1db.集合名称.aggregate([&#123;$unwind:'$字段名称'&#125;]) 12345678910111213db.mask.aggregate([] # 管道1：过滤数据 &#123;$match:&#123;age:&#123;$gt:20&#125;&#125;&#125;, # 查询大于20的信息 # 管道2：分组数据 &#123;$group:&#123;_id:'$gender',counter:&#123;$sum:1&#125;&#125;&#125;, # 管道3：设置显示哪些数据 &#123;$project:&#123;_id:0,name:1,age:1&#125;&#125;, # 管道4：数据排序 &#123;$sort:&#123;_id:1&#125;&#125;, # 管道5： 跳过多少数据 &#123;$skip:1&#125;, &#123;$limit:1&#125;,]) 4.2. 索引 在大量数据中快速查找 步骤一：创造大量数据 123for(i=0;i&lt;100000,i++)&#123; db.mask.insert(name:'test' + i, age:i)&#125; 步骤二：数据查找性能分析 查找姓名为test10000的文档,并通过explain()来进行性能分析 1db.mask.find(&#123;name:'test10000'&#125;).explain('executionStats') # 整体查询时间，96毫秒 步骤三：创建索引 1234db.集合.ensureIndex(&#123;属性:1&#125;) # 1表示升序 db.mask.ensureIndex(&#123;"name":1&#125;)db.mask.find(&#123;name:'test10000'&#125;).explain('executionStats') # 2毫秒 索引命令 建立单一索引 1db.mask.ensureIndex(&#123;"name":1&#125;,&#123;"unique": true&#125;) 建立多个索引 1db.mask.ensureIndex(&#123;"name":1，"age":1&#125;) 查看所有索引 123db.mask.getIndexes()db.mask.dropIndexes(‘索引名称’) # 删除 4.3. 安全:超级管理员和普通用户创建 创建超级管理员 为了更安全的访问MongoDB，需要访问者提供用户名和密码，所以我们需要在mongodb中创建用户，mongoDB采用了角色-用户-数据库的安全管理方式，每个用户被分配了一个角色，不同角色有不同的管理权限，常用角色为如下： root: 只在admin数据库中可用，超级管理员 read：读 readwrite：读写 下面我们来创建超级管理员： 123456use adminad.createUser(&#123; user:'admin', pwd:'123' roles:[&#123;role:'root',db:'admin'&#125;]&#125;) 修改配置文件，启用身份验证 修改配置文件C:\Program Files\MongoDB\Server\4.0\bin\mongod.cfg 查找security字段并重写为： 12security: authorization: enabled 重启服务 1mongo restart # 重启服务 使用超级管理员登录 1mongo -u admin -p 123 --authenticationDatabase admin 里面有以下列表 system.Users:通过db.system.Users.find()查看所有的user信息 system.version 为普通用户创建一个数据库 1use test1 创建普通用户 从超级管理员那里创建一个普通用户账户(无法访问超级数据库) 12345db.createUser(&#123; user:'t1', pwd:'123', roles:[&#123;role:'readWrite', db:'test1'&#125;]&#125;) 使用普通用户登录 为普通用户授权test1的数据库权限 1mongo -u t1 -p 123 -authenticationDatabase test1 4.4. 数据备份和恢复4.1. MongoDB复制复制的工作原理 复制至少需要两个节点A，B… A是主节点，负责处理客户端请求 其余的是从节点，负责复制主节点上的数据 节点的常见搭配方式是：一主一从、一主多从 主节点记录在其上的操作，从节点定期轮询主机诶单获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致 主节点与丛节点进行数据交互保障数据的一致性 复制的特点 N个节点的集群 任何节点可作为主节点 所有写入操作都在主节点 自动故障转移 自动恢复]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB和Python的交互]]></title>
    <url>%2F2019%2F03%2F02%2FMongoDB%E5%92%8CPython%E7%9A%84%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[安装pymongo包 1pip install pymongo 1.MongoDB和Python交互1.1. 连接mongoDB服务器-MongoClient 建立连接并创建客户端 1234# 无安全验证 client = MongoClient('mongodb://localhost:27017/database_name')# 有安全验证client = MongoClient('mongodb://user:pwd@localhost:27017/databse_name') 获取数据库-database 1db = client.py 数据库的方法-类Collection 主要方法有： insert_one insert_many update_one update_many delete_one delete_many find_one find 1234567891011121314151617181920212223# 获取集合stustu = db.stu# 添加文档，返回文档ids1 = &#123;'name':'张三','gender':True&#125;s1_id = stu.insert_one(s1).insert_idprint(s1_id)# 修改文档stu.update_one(&#123;'name':'张三'&#125;,&#123;'$set':&#123;'name':'张三的爸爸'&#125;&#125;)# 删除文档 stu.delete_one(&#123;'name':'张三的爸爸'&#125;)# 查找一个文档，将文档转换为一个元组返回 s2 = stu.find_one(&#123;'name':'李四'&#125;)# 查询多个文档，返回一个Cursor类型对象，用于遍历返回元组形式的文档cursor = stu.find(&#123;'hometown':'重庆'&#125;)# 排序，返回Cursor类型对象 cursor = stu.find().sort('age',DESCENDING)cursor = stu.find().sort([('age',DESCENDING),'name',ASCENDING])]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的基础语法]]></title>
    <url>%2F2019%2F03%2F02%2FJava%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 基本概念1.1. 环境变量环境变量通常是指在操作系统(win10,win7)中，用来指定操作系统运行时需要的一些参数(比如一个国家需要人民，货币，货物…)，一般为一些键值对 Path环境变量的作用-&gt;寻找命令Path环境变量是操作系统外部命令搜索路径 classpath变量的作用-&gt;寻找类文件 1.2. JDK里面有什么？ 1.3. 什么是JRE？JRE是JAVA运行的环境，包括以下几个部分： Java虚拟机： 它是由一个软件虚拟出来的计算机 Java平台核心类文件 其他支持文件 2.Java的基本语法12345678/* 这是一个注释*/public class ClassName&#123; public static void main(String[] args)&#123; object.method(parameters) &#125;&#125; 技巧：在IDEA中输入psvm会直接创建main函数 2.1 Java的数据类型java是一种强类型语言，这就意味着必须为每个变量声明一种类型 整型: int, short, long, byte 浮点型: float, double char类型: 用单引号 boolean类型 2.2. 变量2.2.1. 变量的声明方法声明变量的语法如下：1int var=10; 2.2.2. 常量final123456789public class Main &#123; // 类常量用static final定义 public static final double PRESEM = 2.54; public static void main(String[] args) &#123; //基本常量用final定义 final int jbg = 12; System.out.println("Hello World!"); &#125;&#125; 2.3. 运算符 数学运算符，+,-,*,/ 数学函数与常量: Math.sqrt(),Math.pow(),Math.sin(),Math.tan(),Math.exp().Math.log(),Math.PI 强制类型转换 12double x =9.98;int nx = (int) x; 2.4. 字符串字符串是不可变字符串，无法直接修改但是我们可以修改字符串变量，让他引用另外一个字符串，达到修改的效果 123456789String greet = "Hello";// 子串String s = greet.substring(0,3);// 拼接String msg = greet + "friends";// 判断是否相等greet.equals("help");//判断空串和Null串if(greet!= null &amp;&amp; greet.lend()!=0); 2.4.1. 字符串构造器有时候我们需要一段一段的构造一个字符串，那么我们就可以通过一个字符串构建器来创造1234567//构造字符串构建器StringBuilder builder = new StringBuilder();//添加字符串builder.append(ch);builder.append(ch2);//转换成真正的字符串String finalString = builder.toString(); 2.5. 输入输出2.5.1. 键盘输入读取输入流System.in需要以下两个步骤 创建Scanner对象，并关联System.in 通过Scanner对象的nextLine(),next(),nextInt()方法读取数据 最后通过hasNext(),hasNextInt(),hasNextDouble()判断是否读取完 12345678910111213public class test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("What is your name?"); String name = in.nextLine(); System.out.println("What is your age?"); int age = in.nextInt(); System.out.println("Hello, " + name + ". you age is " + age); &#125;&#125; 2.5.2. 格式化输出1System.out.printf("hello, %s, you age is %d", name,age) 2.5.3. 文件输入和输出文件读取 要想对文件进行读取，有以下几个步骤 用File对象构造一个Scanner对象 通过Scanner对象的nextLine(),next(),nextInt()方法读取数据 12Scanner in = new Scanner(Path.get("C:\\mydirectory\\myfile.txt"), "UTF-8");String msg = in.nextLine(); 文件写入 PrinterWriter out = new PrinterWriter(“myfile.txt”, “UTF-8”) 2.6. 循环控制流程 2.7. 数组 数组是一种数据结构，用来储存同一类型值得集合，通过一个整型下标就可以访问数组中的每个值，如果a是一个整型数组，a[i]就是数组中下标为i的整数 数组是用来储存同一数据类型的集合 一旦创建，不可改变大小 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) throws IOException &#123; // 创建数组，指定数组长度(不可更改),创建后，所有元素初始化为0，布尔为false， 对象数组为null int[] a = new int[10]; // 给数组赋值 for (int i=0; i&lt;a.length; i++)&#123; a[i] = i; &#125; // foreach循环 for (int element: a)&#123; System.out.println(element); &#125; // 数组初始化(无需指定长度) int[] b = &#123;1,3,5,8,6,12&#125;; // 数组拷贝(指向内存同一个区域) int[] c = b; int[] c_hard_copy = Arrays.copyOf(b, b.length); // 数组排序 Arrays.sort(b); // 命令行参数 在main方法中的String[] args就是一个字符串数组，接收一系列命令行参数 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django的基本用法教程-Part-I]]></title>
    <url>%2F2019%2F03%2F02%2FDjango%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%95%99%E7%A8%8B-Part-I%2F</url>
    <content type="text"><![CDATA[1. Django基础1.1. Django简介1.2. Django安装1234pip install Djangoimport djangoprint(django.get_version()) # 2.1.7 1.3. 创建Django项目在你希望创建django项目的文件夹下输入1django-admin startproject mysite mysite项目下面有如下的文件1234567mysite/ manage.py # 管理 Django 项目的命令行工具 mysite/ __init__.py # 一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包 settings.py # Django 项目的配置文件 urls.py # Django 项目的 URL 声明 wsgi.py # 项目的运行在 WSGI 兼容的Web服务器上的入口 在mysite文件夹内运行1python manage.py runserver # 启动了一个自带的简易服务器 现在，服务器正在运行，浏览器访问 https://127.0.0.1:8000/。你将会看到一个“祝贺”页面，随着一只火箭发射，服务器已经运行了。 1.4. 创建一个应用你的应用可以存放在任何 Python path 中定义的路径。在这个教程中，我们将在你的 manage.py 同级目录下创建投票应用。这样它就可以作为顶级模块导入，而不是 mysite 的子模块。 创建应用： 1python manage.py startapp polls 这将会创建一个 polls 目录，它的目录结构大致如下： 123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 1.5. 创建第一个视图让我们开始编写第一个视图吧。打开 polls/views.py，把下面这些 Python 代码输入进去： 12345from django.http import HttpResponsedef index(request): return HttpResponse("Hello, world. You're at the polls index.") 这是 Django 中最简单的视图。如果想看见效果，我们需要将一个 URL 映射到它——这就是我们需要 URLconf 的原因了。为了创建 URLconf，请在 polls 目录里新建一个 urls.py 文件。你的应用目录现在看起来应该是这样 12345678910polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py urls.py views.py 在 polls/urls.py 中，输入如下代码： 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下： 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 函数 include() 允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到URLconf 以供进一步处理 你现在把 index 视图添加进了 URLconf。可以验证是否正常工作 用你的浏览器访问 http://localhost:8000/polls/来检查 函数path的使用函数 path() 具有四个参数，两个必须参数：route和 view，两个可选参数：kwargs 和 name。现在，是时候来研究这些参数的含义了。 route: route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项 view:当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 kwargs: 任意个关键字参数可以作为一个字典传递给目标视图函数。 name: 为你的 URL 取名能使你在 Django 的任意地方唯一地引用它 2. Django的数据库部分2.1. 数据库配置现在，打开 mysite/settings.py 。这是个包含了 Django 项目设置的 Python 模块。通常默认SQLite数据库 在数据库中创建表1python manage.py migrate 这个 migrate 命令检查 INSTALLED_APPS 设置，为其中的每个应用创建需要的数据表，至于具体会创建什么，这取决于你的 mysite/settings.py 设置文件和每个应用的数据库迁移文件 这个命令所执行的每个迁移操作都会在终端中显示出来 2.2. 创建模型定义模型 - 也就是数据库结构设计和附加的其它元数据。 在这个简单的投票应用中，需要创建两个模型：问题 Question 和选项 Choice。Question 模型包括问题描述和发布时间。Choice 模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。 polls/models.py 文件 中编写如下代码 123456789101112131415161718192021222324from django.db import models# Create your models here.# 每个模型被表示为 django.db.models.Model 类的子类class Question(models.Model): # 每个模型有一些类变量，它们都表示模型里的一个数据库字段。 # 每个字段都是 Field 类的实例，告诉 Django 每个字段要处理的数据类型。 # 字符字段被表示为 CharField question_text = models.CharField(max_length=200) # 日期时间字段被表示为 DateTimeField pub_date = models.DateTimeField('date published') def __str__(self): return self.question_textclass Choice(models.Model): # 使用 ForeignKey 定义了一个关系。这将告诉 Django，每个 Choice 对象都关联到一个 Question 对象。 # Django 支持所有常用的数据库关系：多对一、多对多和一对一。 question = models.ForeignKey(Question, on_delete = models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) def __str__(self): return self.choice_text 2.3. 激活模型通过上述代码，djanao可以 为这个应用创建数据库 schema（生成 CREATE TABLE 语句） 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API 但是首先得把 polls 应用安装到我们的项目里 为了在我们的工程中包含这个应用，我们需要在配置类 INSTALLED_APPS 中添加设置。因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样： 123456789INSTALLED_APPS = [ &apos;polls.apps.PollsConfig&apos;, &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;,] 然后为polls创建数据库 1python manage.py makemigrations polls 通过运行 makemigrations 命令，Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次 迁移。 Django 有一个自动执行数据库迁移并同步管理你的数据库结构的命令 - 这个命令是 migrate，我们马上就会接触它 - 但是首先，让我们看看迁移命令会执行哪些 SQL 语句。sqlmigrate 命令接收一个迁移的名称，然后返回对应的 SQL： 1python manage.py sqlmigrate polls 0001 输出： 123456789101112131415161718192021222324252627282930BEGIN;---- Create model Choice--CREATE TABLE "polls_choice" ( "id" serial NOT NULL PRIMARY KEY, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL);---- Create model Question--CREATE TABLE "polls_question" ( "id" serial NOT NULL PRIMARY KEY, "question_text" varchar(200) NOT NULL, "pub_date" timestamp with time zone NOT NULL);---- Add field question to choice--ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");ALTER TABLE "polls_choice" ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id" FOREIGN KEY ("question_id") REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED;COMMIT; 数据库的表名是由应用名(polls)和模型名的小写形式( question 和 choice)连接而来 主键(IDs)会被自动创建 默认的，Django 会在外键字段名后追加字符串 “_id” 。 外键关系由 FOREIGN KEY 生成。你不用关心 DEFERRABLE 部分，它只是告诉 PostgreSQL，请在事务全都执行完之后再创建外键关系。 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment (MySQL)、 serial (PostgreSQL)和 integer primary key autoincrement (SQLite)，Django 会帮你自动处理 这个 sqlmigrate 命令并没有真正在你的数据库中的执行迁移 - 它只是把命令输出到屏幕上，让你看看 Django 认为需要执行哪些 SQL 语句。 现在，再次运行 migrate 命令，在数据库里创建新定义的模型的数据表： 12345python manage.py migrate# Operations to perform:# Apply all migrations: admin, auth, contenttypes, polls, sessions# Running migrations:# Applying polls.0001_initial... OK 这个 migrate 命令选中所有还没有执行过的迁移（Django 通过在数据库中创建一个特殊的表 django_migrations 来跟踪执行过哪些迁移）并应用在数据库上 - 也就是将你对模型的更改同步到数据库结构上。 迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。 现在，你只需要记住，改变模型需要这三步： 编辑 models.py 文件，改变模型。 运行 python manage.py makemigrations 为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 2.4. 初试 API现在让我们进入交互式 Python 命令行，尝试一下 Django 为你创建的各种 API。通过以下命令打开 Python 命令行 1python manage.py shell 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; from polls.models import Choice, Question # Import the model classes we just wrote.# No questions are in the system yet.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# Create a new Question.# Support for time zones is enabled in the default settings file, so# Django expects a datetime with tzinfo for pub_date. Use timezone.now()# instead of datetime.datetime.now() and it will do the right thing.&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())# Save the object into the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()# Now it has an ID.&gt;&gt;&gt; q.id1# Access model field values via Python attributes.&gt;&gt;&gt; q.question_text"What's new?"&gt;&gt;&gt; q.pub_datedatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)# Change values by changing the attributes, then calling save().&gt;&gt;&gt; q.question_text = "What's up?"&gt;&gt;&gt; q.save()# objects.all() displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt; 2.5. 介绍Django的管理页面创建一个管理员账号1python manage.py createsuperuser 12345Username: adminEmail address: admin@example.comPassword: **********Password (again): *********Superuser created successfully. 启动开发服务器Django 的管理界面默认就是启用的。让我们启动开发服务器，看看它到底是什么样的。 1python manage.py runserver 现在，打开浏览器，转到你本地域名的 “/admin/“ 目录， – 比如 “http://127.0.0.1:8000/admin/“ 。你应该会看见管理员登录界面： 进入管理页面通过密码进入页面如下 你将会看到几种可编辑的内容：组和用户。它们是由 django.contrib.auth 提供的，这是 Django 开发的认证框架 向管理页面加入投票应用告诉管理页面，问题 Question 对象需要被管理。打开 polls/admin.py 文件，把它编辑成下面这样 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 3. 视图3.1. 什么是视图视图的概念是「一类具有相同功能和模板的网页的集合」。比如，在一个博客应用中，你可能会创建如下几个视图 博客首页——展示最近的几项内容。 内容“详情”页——详细展示某项内容。 以年为单位的归档页——展示选中的年份里各个月份创建的内容 评论处理器——用于响应为一项内容添加评论的操作。 而在我们的投票应用中，我们需要下列几个视图 问题索引页——展示最近的几个投票问题 问题详情页——展示某个投票的问题和不带结果的选项列表。 问题结果页——展示某个投票的结果。 投票处理器——用于响应用户为某个问题的特定选项投票的操作。 在 Django 中，网页和其他内容都是从视图派生而来。每一个视图表现为一个简单的 Python 函数 一个 URL 模式定义了某种 URL 的基本格式——举个例子：/newsarchive/&lt;year&gt;/&lt;month&gt;/。 为了将 URL 和视图关联起来，Django 使用了 ‘URLconfs’ 来配置。URLconf 将 URL 模式映射到视图。 3.2. 编写更多视图在让我们向 polls/views.py 里添加更多视图。这些视图有一些不同，因为他们接收参数： 123456789def detail(request, question_id): return HttpResponse("You're looking at question %s." % question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." % question_id) 把这些新视图添加进 polls.urls 模块里，只要添加几个 url() 函数调用就行： 1234567891011121314from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 然后看看你的浏览器，如果你转到 “/polls/34/“ ，Django 将会运行 detail() 方法并且展示你在 URL 里提供的问题 ID。再试试 “/polls/34/vote/“ 和 “/polls/34/vote/“ ——你将会看到暂时用于占位的结果和投票页。 当某人请求你网站的某一页面时——比如说， “/polls/34/“ ，Django 将会载入 mysite.urls 模块，因为这在配置项 ROOT_URLCONF 中设置了。然后 Django 寻找名为 urlpatterns 变量并且按序匹配正则表达式。在找到匹配项 ‘polls/‘，它切掉了匹配的文本（”polls/“），将剩余文本——“34/“，发送至 ‘polls.urls’ URLconf 做进一步处理。在这里剩余文本匹配了 ‘int:question_id/‘，使得我们 Django 以如下形式调用 detail(): 1detail(request=&lt;HttpRequest object&gt;, question_id=34) 3.3. 写一个真正的视图 每个视图必须的两个步骤 返回一个包含请求页面内容的HttpResponse对象 抛出异常Http404 其他你自己定义的操作 你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 Django 自带的，或者其他第三方的），可以生成一个 PDF 文件，可以输出一个 XML，创建一个 ZIP 文件，你可以做任何你想做的事，使用任何你想用的 Python 库。 首先，在你的 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。 你项目的 TEMPLATES 配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录。这就是为什么尽管我们没有像在第二部分中那样修改 DIRS 设置，Django 也能正确找到 polls 的模板位置的原因。 在你刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，所以你只需要使用 polls/index.html 就可以引用到这一模板了。 123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href="/polls/&#123;&#123; question.id &#125;&#125;/"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 然后，让我们更新一下 polls/views.py 里的 index 视图来使用模板： 123456789from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context) 用你的浏览器访问 “/polls/“ ，你将会看见一个无序列表 3.4. 抛出404错误现在，我们来处理投票详情视图——它会显示指定投票的问题标题。下面是这个视图的代码： 1234def detail(request, question_id): # 试用 get() 函数获取一个对象，如果不存在就抛出 Http404 question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;)]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程6-Shape和Selector结合用于自定义控件]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B6-Shape%E5%92%8CSelector%E7%BB%93%E5%90%88%E7%94%A8%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.Selector和hape的说明 在Android开发中，使用shape可以很方便的帮我们画出想要的背景，相对于png图片来说，使用shape可以减少安装包的大小，而且能够更好的适配不同的手机。 Selector（背景选择器）主要是用来改变一个按钮控件的背景 一般使用如下格式自定义控件 1234567891011&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;Shape&gt; &lt;/Shape&gt; &lt;/item&gt;&lt;/selector &gt; 2. Shape的使用首先看官网的说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] //共有4种类型，矩形（默认）/椭圆形/直线形/环形 // 以下4个属性只有当类型为环形时才有效 android:innerRadius="dimension" //内环半径 android:innerRadiusRatio="float" //内环半径相对于环的宽度的比例，比如环的宽度为50,比例为2.5,那么内环半径为20 android:thickness="dimension" //环的厚度 android:thicknessRatio="float" //环的厚度相对于环的宽度的比例 android:useLevel="boolean"&gt; //如果当做是LevelListDrawable使用时值为true，否则为false. &lt;corners //定义圆角 android:radius="dimension" //全部的圆角半径 android:topLeftRadius="dimension" //左上角的圆角半径 android:topRightRadius="dimension" //右上角的圆角半径 android:bottomLeftRadius="dimension" //左下角的圆角半径 android:bottomRightRadius="dimension" /&gt; //右下角的圆角半径 &lt;gradient //定义渐变效果 android:type=["linear" | "radial" | "sweep"] //共有3中渐变类型，线性渐变（默认）/放射渐变/扫描式渐变 android:angle="integer" //渐变角度，必须为45的倍数，0为从左到右，90为从上到下 android:centerX="float" //渐变中心X的相当位置，范围为0～1 android:centerY="float" //渐变中心Y的相当位置，范围为0～1 android:startColor="color" //渐变开始点的颜色 android:centerColor="color" //渐变中间点的颜色，在开始与结束点之间 android:endColor="color" //渐变结束点的颜色 android:gradientRadius="float" //渐变的半径，只有当渐变类型为radial时才能使用 android:useLevel=["true" | "false"] /&gt; //使用LevelListDrawable时就要设置为true。设为false时才有渐变效果 &lt;padding //内部边距 android:left="dimension" android:top="dimension" android:right="dimension" android:bottom="dimension" /&gt; &lt;size //自定义的图形大小 android:width="dimension" android:height="dimension" /&gt; &lt;solid //内部填充颜色 android:color="color" /&gt; &lt;stroke //描边 android:width="dimension" //描边的宽度 android:color="color" //描边的颜色 // 以下两个属性设置虚线 android:dashWidth="dimension" //虚线的宽度，值为0时是实线 android:dashGap="dimension" /&gt; //虚线的间隔&lt;/shape&gt; 2.1. 直角与圆角矩形1234567891011121314&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;corners android:radius="10dp"/&gt; &lt;solid android:color="@color/holo_green_dark"/&gt; &lt;stroke android:width="2dp" android:color="@color/white"/&gt;&lt;/shape&gt; 2.2. 圆形1234567891011&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;gradient android:type="linear" android:angle="45" android:startColor="@color/holo_green_dark" android:centerColor="@color/holo_blue_dark" android:endColor="@color/holo_blue_bright"/&gt;&lt;/shape&gt; 3. Selector和Shape的结合使用通过实现一个按钮，按下前和按下后的不同变化来演示这个功能 创建正常状态下的button样式button_default.xml，可用未点击 1234567891011121314151617181920212223&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;gradient android:angle="45" android:startColor="#6a938b" android:endColor="#051c3b"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建点击状态下的样式buttom_pressed.xml 12345678910111213141516171819202122&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;gradient android:angle="45" android:startColor="#9a5edf" android:endColor="#20549b"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建不可用状态下的样式buttom_disabled.xml 1234567891011121314151617181920&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;solid android:color="#858687"/&gt; &lt;corners android:radius="15dp"/&gt; &lt;padding android:bottom="7dp" android:left="7dp" android:right="7dp" android:top="7dp"/&gt; &lt;stroke android:width="2dp" android:color="#ffff"/&gt;&lt;/shape&gt; 创建一个selector来关联这些shape：custeom_button.xml 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="false" android:state_enabled="true" android:drawable="@drawable/button_default"/&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/button_pressed"/&gt; &lt;item android:state_enabled="false" android:drawable="@drawable/button_disabled"/&gt;&lt;/selector&gt; 在主button中引入这个selector 12345678910111213&lt;Button android:id="@+id/custom_choose" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="10dp" android:background="@drawable/custom_button" /&gt;&lt;Switch android:id="@+id/if_enable" android:layout_width="wrap_content" android:layout_height="wrap_content" android:checked="true" android:text="Enabled"/&gt; 在主活动中写入逻辑关系 123456789101112131415161718192021222324252627282930313233public class CustomActivity extends AppCompatActivity &#123; private Button custom_BT; private Switch if_checked; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_custom); custom_BT = (Button)findViewById(R.id.custom_choose); if_checked = (Switch)findViewById(R.id.if_enable); custom_BT.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(CustomActivity.this,"CLicked", Toast.LENGTH_SHORT).show(); &#125; &#125;); if_checked.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked)&#123; custom_BT.setEnabled(true); &#125;else &#123; custom_BT.setEnabled(false); &#125; &#125; &#125;); &#125;&#125; 4. 通过Style保存刚刚设计的样式1234&lt;style name="CustomButton" parent="Widget.AppCompat.Button"&gt; &lt;item name = "android:background"&gt;@drawable/custom_button&lt;/item&gt; &lt;item name = "android:textColor"&gt;#fff&lt;/item&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程5-数据存储]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B5-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[1. 持久化技术 将那些内存的瞬间数据保存到存储设备中，保证即使在手机或者电脑关机的状态下，数据不会丢失， Android有三种持久化方式 文件存储 SharedPreference储存 数据库储存 2. 文件储存适用于存储一些简单的额文本数据或者二进制数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class DataSaveActivity extends AppCompatActivity &#123; EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_data_save); editText = (EditText)findViewById(R.id.edit); // 当从主活动转到这里的时候，会加载上一步的文本 String inputText = load(); // !TextUtils.isEmpty(inputText):当传入的字符串登录null或者空的时候，返回trye if (!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); Toast.makeText(this, "Restoring success", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = editText.getText().toString(); save(inputText); &#125; // 将数据保存到文件中 // Context类体用了一个openFileOutput()方法，用于数据储存到指定文件 // 输入参数: 1: 文件名，所有文件都默认放在/data/data/&lt;package name&gt;/files目录下 // 2: 文件操作模式，private和append public void save(String inputText)&#123; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput("data", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); Toast.makeText(this, "Text has been saved", Toast.LENGTH_SHORT).show(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if (writer !=null)&#123; writer.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; // 从文件中读取数据 // Context类提供一个openFileInput方法用于从文件读取数据，接收一个参数：文件名 // 系统自动从/data/data/&lt;package name&gt;/files/目录下去加载这个文件，返回一个FileInputStream对象 // 通过java流将数据读取出来 public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content =new StringBuilder(); try&#123; in = openFileInput("data"); // 通过BufferedReader进行一行行的读取 reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while ((line = reader.readLine())!=null)&#123; content.append(line); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if (reader!=null)&#123; try&#123; reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125; &#125; 3. SharedPreferences存储 SharedPreference是通过键值对存储数据 3.1. 将数据存储到Sharepreferences中要想适用SharePreference来存储数据，首先需要获得SharePreference对象，Android提供了3中方式获取SharePreference对象 Context类中的getSharedPreferences(filename, MODE)方法 第一个参数是用于指定SharedPreferences的文件名称，保存在/data/data/&lt;package name&gt;/shared_prefs/目录下第二个参数是默认操作模式，MODE_PRIVATE Activity类中的getPreferences()方法 这个方法和上面的很类似，不过它只接收一个操作模式参数 PrefenceManager类中的getDefaultSharedPreferences()方法 这是一个静态方法接收context参数，并自动使用当前程序包名作为前缀来命名SharedPreferences文件 得到了SharePreference对象后，我们就可向里面写入数据了，主要分为3步完成： (1). 调用SharePreference对象的edit()方法获取一个SharePreferences.Editor对象(2). 向SharePreferences.Editor对象添加数据，putBoolean(),putString()(3). 调用apply()方法将添加的数据提交，完成数据的存储操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public class DataSaveActivity extends AppCompatActivity &#123; private EditText editText,account,pw; private Button login; private CheckBox rememberPW; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_data_save); editText = (EditText)findViewById(R.id.edit); account = (EditText)findViewById(R.id.account); pw = (EditText)findViewById(R.id.pw); login = (Button)findViewById(R.id.login); rememberPW = (CheckBox)findViewById(R.id.remeber_pw); pref = PreferenceManager.getDefaultSharedPreferences(this); boolean isRemember = pref.getBoolean("remember_password",false); if (isRemember)&#123; String accountText = pref.getString("account",""); String passwordText = pref.getString("password", ""); account.setText(accountText); pw.setText(passwordText); rememberPW.setChecked(true); &#125; login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String accountText = account.getText().toString(); String passwordText = pw.getText().toString(); // 如果账号是admin，且密码是123456，就任务登录成功 if (accountText.equals("admin") &amp;&amp; passwordText.equals("123456"))&#123; editor = pref.edit(); if (rememberPW.isChecked())&#123; editor.putBoolean("remember_password", true); editor.putString("account", accountText); editor.putString("password",passwordText); &#125; else &#123; editor.clear(); &#125; editor.apply(); Toast.makeText(DataSaveActivity.this, "You got it", Toast.LENGTH_SHORT).show(); &#125; else&#123; Toast.makeText(DataSaveActivity.this, "Wrong account or password", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); // 当从主活动转到这里的时候，会加载上一步的文本 String inputText = load(); // !TextUtils.isEmpty(inputText):当传入的字符串登录null或者空的时候，返回trye if (!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); Toast.makeText(this, "Restoring success", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = editText.getText().toString(); save(inputText); &#125; // 将数据保存到文件中 // Context类体用了一个openFileOutput()方法，用于数据储存到指定文件 // 输入参数: 1: 文件名，所有文件都默认放在/data/data/&lt;package name&gt;/files目录下 // 2: 文件操作模式，private和append public void save(String inputText)&#123; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput("data", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); Toast.makeText(this, "Text has been saved", Toast.LENGTH_SHORT).show(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if (writer !=null)&#123; writer.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; // 从文件中读取数据 // Context类提供一个openFileInput方法用于从文件读取数据，接收一个参数：文件名 // 系统自动从/data/data/&lt;package name&gt;/files/目录下去加载这个文件，返回一个FileInputStream对象 // 通过java流将数据读取出来 public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content =new StringBuilder(); try&#123; in = openFileInput("data"); // 通过BufferedReader进行一行行的读取 reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while ((line = reader.readLine())!=null)&#123; content.append(line); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; if (reader!=null)&#123; try&#123; reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125;&#125; 4. LitePal数据库存储LitPal是一款开源的Android数据库框架，采用对象关系映射(ORM)模式，并将我们平时开发常用的一些数据库功能进行了一些封装 4.1. 配置LitePal在app/build.gradle中添加implments 123dependencies &#123; implementation &apos;org.litepal.android:java:3.0.0&apos;&#125; 然后需要配置litepal.xml文件，右击app/src/main目录-&gt;New-&gt;Directory创建一个assets目录，然后在里面创建litepal.xml文件 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value = "BookStore"&gt;&lt;/dbname&gt; &lt;version value = "1"&gt;&lt;/version&gt; &lt;list&gt;&lt;/list&gt; &lt;/litepal&gt; 然后在AndroidManifest.xml中配置一下android:name=&quot;org.litepal.LitePalApplication&quot; 4.2. 创建和升级数据库首先配置adb C:\Users\HAO\AppData\Local\Android\Sdk\platform-tools添加到系统变量中]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程4-BroadcastReceiver的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B4-BroadcastReceiver%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 广播机制BroadcastReceiver，顾名思义就是“广播接收者”的意思，它是Android四大基本组件之一，这种组件本质上是一种全局的监听器，用于监听系统全局的广播消息。它可以接收来自系统和应用的的广播。 BroadcastReceiver用于接收程序（包括系统程序和一般应用）通过sendBroadcast()方法发出的Broadcast intents Android的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就会只接收自己关系的广播内容 广播内容来自系统或者其他应用程序 发送广播:Intent 接收广播: Broadcaset Receiver 广播的分类 标准广播：异步执行，广播发出后，所有的接收器几乎同时接收到这个广播，没有先后顺序之分 有序广播： 同步执行，广播发出后，同意时间只有一个广播接收器能够接受这个广播，当接收完毕后才会继续传递给下一个 2.程序启动BroadcastReceiver的步骤： 创建需要启动BroadcastReceiver的Intent。 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver。其中sendBroadcast发送的是普通广播，sendOrderedBroadcast发送的是有序广播。 3.创建BroadcastReceiver的步骤3.1. 创建BroadcastReceiver的自雷由于BroadcastReceiver本质上是一种监听器，所以创建BroadcastReceiver的方法也非常简单，只需要创建一个BroadcastReceiver的子类然后重写onReceive (Context context, Intentintent)方法即可。 3.2. 注册BroadcastReceiver一旦实现了BroadcastReceiver，接下就应该指定该BroadcastReceiver能匹配的Intent即注册BroadcastReceiver。注册BroadcastReceiver的方式有两种： 静态注册： 这种方法是在配置AndroidManifest.xml配置文件中注册，通过这种方式注册的广播为常驻型广播，也就是说如果应用程序关闭了，有相应事件触发，程序还是会被系统自动调用运行 1234567&lt;!-- 在配置文件中注册BroadcastReceiver能够匹配的Intent --&gt;&lt;receiver android:name="com.example.test.MyBroadcastReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MyBroadcastReceiver"&gt;&lt;/action&gt; &lt;category android:name="android.intent.category.DEFAULT"&gt;&lt;/category&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册: 种方法是通过代码在.Java文件中进行注册。通过这种方式注册的广播为非常驻型广播，即它会跟随Activity的生命周期，所以在Activity结束前我们需要调用unregisterReceiver(receiver)方法移除它。 123456//通过代码的方式动态注册MyBroadcastReceiverMyBroadcastReceiver receiver=new MyBroadcastReceiver();IntentFilter filter=new IntentFilter();filter.addAction("android.intent.action.MyBroadcastReceiver");//注册receiverregisterReceiver(receiver, filter); 如果我们在Activity中注册了BroadcastReceiver，当这个Activity销毁的时候要主动撤销注册否则会出现异常。 1234567@Overrideprotected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); //当Activity销毁的时候取消注册BroadcastReceiver unregisterReceiver(receiver);&#125; 4. BroadCastReceiver的生命周期BroadcastReceiver的生命周期，从对象调用它开始，到onReceiver方法执行完成之后结束。另外，每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完就销毁，如果BroadcastReceiver的onReceiver方法中不能在10秒内执行完成，Android会出现ANR异常。所以不要在BroadcastReceiver的onReceiver方法中执行耗时的操作。 5. 实例最新Android不再兼容静态注册，尽量用动态注册 先定义两个广播接收器 1234567891011121314151617public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //TODO String msg = intent.getStringExtra("msg"); Log.d("TAG", "接收的消息时： " + msg); setResultData("MyBroadcastReceiver接收到广播"); Toast.makeText(context, "时间： " + new SimpleDateFormat("yyyy-mm-dd hh.mm.ss").format(new Date()) + "\nMyBroadcastReceiver收到Action名为: " + intent.getAction().toString() + "的广播\nComponent: " + intent.getComponent() + "\nmsg: " + msg, Toast.LENGTH_LONG).show(); &#125;&#125; 12345678910111213public class SecondBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String msg=intent.getExtras().get("msg").toString(); String result=getResultData(); Toast.makeText(context,"时间："+new SimpleDateFormat("yyyy-MM-dd hh.mm.ss").format(new Date()) +"\nSecondBroadcastReceiver收到Action名为："+intent.getAction().toString() +"的广播 \nComponent:"+intent.getComponent() +"\nmsg:"+msg+"\n上一个接受者传来的reult:"+result, Toast.LENGTH_LONG).show(); &#125;&#125; 然后再在activity中发送广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class BroadcastDemoActivity extends AppCompatActivity &#123; Button general_BT, order_BT; MyBroadcastReceiver receiver; SecondBroadcastReceiver secondReceiver; private static final String ACTION = "com.android.broadcast.RECEIVER_ACTION"; private IntentFilter intentFilter; String TAG = "DEBUG"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_broadcast_demo); general_BT = (Button)findViewById(R.id.general_bc); order_BT = (Button)findViewById(R.id.order_bc); receiver=new MyBroadcastReceiver(); secondReceiver = new SecondBroadcastReceiver(); RegisterBroadcast(receiver,200); RegisterBroadcast(secondReceiver,100); general_BT.setOnClickListener(new Mylistener()); order_BT.setOnClickListener(new Mylistener()); &#125; private void RegisterBroadcast(BroadcastReceiver receiver, int Value)&#123; intentFilter = new IntentFilter(); intentFilter.addAction(ACTION); intentFilter.setPriority(Value); registerReceiver(receiver,intentFilter); &#125; class Mylistener implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id)&#123; case R.id.general_bc: Intent intent = new Intent("com.android.broadcast.RECEIVER_ACTION"); intent.putExtra("msg","我在发送广播！这智商一个普通的广播，" + "你们无法通过abortBroadcast()方法停止广播的传播， " + "也无法往Broadcast中存入数据因为他是异步的"); sendBroadcast(intent); Log.d(TAG, "发送成功啦！！！！"); break; case R.id.order_bc: Intent intent2 =new Intent(); intent2.setAction("com.android.broadcast.RECEIVER_ACTION"); intent2.putExtra("msg", "我在发送一个有序的广播，"+ "你们可以通过abortBroadcast()的方法停止广播的传播，"+ "也可以向Broadcast中存入数据"); sendOrderedBroadcast(intent2, null); break; default: break; &#125; &#125; &#125; @Override protected void onStop() &#123; super.onStop(); this.unregisterReceiver(receiver); this.unregisterReceiver(secondReceiver); &#125;&#125; 结果如下：]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程3-RecycleView以及其Adapter的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B3-RecycleView%E4%BB%A5%E5%8F%8A%E5%85%B6Adapter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. RecyclerView介绍 ListView的运行效率低 RecyclerView是增强版本的ListView 2. RecyclerView的三部曲2.1. 首先设置recyclerView的布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".RecycleDemoActivity"&gt; &lt;LinearLayout android:id="@+id/layout01" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:id="@+id/linearLayout_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="线性布局"/&gt; &lt;Button android:id="@+id/grid_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="网格布局"/&gt; &lt;Button android:id="@+id/staggeredLayout_recycle" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="瀑布布局"/&gt; &lt;/LinearLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/my_recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 2.2. 然后创建recyclerView的布局文件1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="100dp"&gt; &lt;TextView android:id="@+id/text_view" android:textSize="20dp" android:layout_width="wrap_content" android:text="6666" android:layout_marginTop="30dp" android:layout_gravity="center" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 2.3. 自定义RecyclerAdapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 需要重写// onCreateViewHolder(): 创建ViewHolder实例，并传入布局文件，返回这个实例// onBindViewHolder()：对RecyclerView子项的数据赋值，会在每个子项被滚动到屏幕内的时候执行，// 通过position参数得到当前项的Fruit实例，再讲数据设置到ViewHolder的TextView中// getItemCount(): 告诉RecyclerView一共有多少子项，直接返回数据源的长度public class RecycleAdapter extends RecyclerView.Adapter&lt;RecycleAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; mList; private Context context; // RecycleAdapter也有一个自己的构造函数 // 把要展示的内容传入 public RecycleAdapter(List&lt;String&gt; list, Context context)&#123; this.mList = list; this.context = context; &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; // 定义一个内部类MyViewHolder继承RecyclerView.ViewHolder // ViewHolder的构造函数要传入一个View参数，这个参数通常是RecyclerView子项的最外层布局， // 那么我们就可以通过findViewById()方法来获取布局中的TextView public class MyViewHolder extends RecyclerView.ViewHolder &#123; public TextView mView; public MyViewHolder(@NonNull View itemView) &#123; super(itemView); mView = itemView.findViewById(R.id.text_view); &#125; &#125; //创建ViewHolder //onCreateViewHolder方法创建一个viewHolder，viewholder可以理解为一条数据的展示布局，这里我们自定义类LinearViewHolder创建一个只有TextView的item //这里我们需要创建每条布局使用的layout：recycle_item @NonNull @Override public MyViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; return new MyViewHolder(LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.recycle_item, viewGroup, false)); &#125; //填充视图 //onBindViewHolder方法为item的UI绑定展示数据 @Override public void onBindViewHolder(@NonNull final MyViewHolder holder, final int position) &#123; holder.mView.setText(mList.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v) &#123; Toast.makeText(context, "点击子项"+position, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; public void addData(int position) &#123; mList.add(position, "Insert One"); notifyItemInserted(position); &#125; public void removeData(int position) &#123; mList.remove(position); notifyItemRemoved(position); &#125; public void clearALL()&#123; mList.clear(); notifyDataSetChanged(); &#125;&#125; 2.4. 在Activity中实现adapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class RecycleDemoActivity extends AppCompatActivity &#123; private Button linearBT, gridBT, starBT; private RecyclerView mRecyclerView; private RecycleAdapter mMyAdapter; private RecyclerView.LayoutManager mLayoutManager; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycle_demo); linearBT = (Button)findViewById(R.id.linearLayout_recycle); gridBT = (Button)findViewById(R.id.grid_recycle); starBT = (Button)findViewById(R.id.staggeredLayout_recycle); // RecyclerView的三部曲 01: 获取RecyclerView对象 mRecyclerView = (RecyclerView)findViewById(R.id.my_recycler_view); initData(); linearBT.setOnClickListener(new ButtonClicked()); gridBT.setOnClickListener(new ButtonClicked()); starBT.setOnClickListener(new ButtonClicked());// // 添加水平分割线// mRecyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL)); &#125; private void initData() &#123; list = new ArrayList&lt;&gt;(); for (int i=0;i&lt;50;i++)&#123; list.add("Item" + i); &#125; &#125; class ButtonClicked implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.linearLayout_recycle: mLayoutManager = new LinearLayoutManager(getApplicationContext()); break; case R.id.grid_recycle: mLayoutManager = new GridLayoutManager(getApplicationContext(),4); break; case R.id.staggeredLayout_recycle: //如果传入 StaggeredGridLayoutManager.VERTICAL则该布局支持纵向滑动，那么前面的 4 则指的是 4列。 //如果传入 StaggeredGridLayoutManager.HORIZONTAL，则该布局支持横向滑动，那么前面的4 则指的是 4行 mLayoutManager = new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL); break; default: mLayoutManager = new LinearLayoutManager(getApplicationContext()); break; &#125; //RecyclerView的三部曲 02：设置布局管理器 mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.addItemDecoration(new DividerItemDecoration(getApplicationContext(),DividerItemDecoration.VERTICAL)); // RecyclerView的三部曲 03： 添加适配器，适配器需要重写 mMyAdapter = new RecycleAdapter(list, getApplicationContext()); mRecyclerView.setAdapter(mMyAdapter); //设置Item增加、移除动画 mRecyclerView.setItemAnimator(new DefaultItemAnimator()); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: mMyAdapter.addData(1); break; case R.id.remove_item: mMyAdapter.removeData(1); break; &#125; return true; &#125;&#125; 3. 实现效果]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程2-ListView以及Adapter的使用]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B2-ListView%E4%BB%A5%E5%8F%8AAdapter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. ListView的基本用法允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚出屏幕 布局文件中增加 ListView 定义一个实体类，用于设置需要保存的数据结构 源码中构造适配器 Adapter ，准备子项布局 通过id找到ListView的实例 ，准备数据结构 ListView设置适配器，派生ArrayAdapter 1.1. 增加ListView首先在Activity里面添加ListView插件，在布局文件中写入如下代码 12345678910111213&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".ListViewActivity"&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 1.2. 定义一个实体类，用于设置需要保存的数据结构定义一个实体类，作为ListView适配器的适配类型，新建类Fruit 1234567891011121314151617public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId)&#123; this.name = name; this.imageId = imageId; &#125; public int getImageId() &#123; return imageId; &#125; public String getName() &#123; return name; &#125;&#125; 1.3. 准备子项布局子项布局就是你需要在listview中每一行显示的格式，新建一个布局文件，写入如下数据 12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:orientation="vertical" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp"/&gt;&lt;/LinearLayout&gt; 1.4. 自定义适配器，继承ArrayAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; // 将上下文， listview子项布局的id和数据传入 public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects)&#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; // 每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前的Fruit实例 // 使用已经缓存好的view View view; ViewHolder viewHolder; if (convertView == null)&#123; // inflate出子项布局，实例化其中的图片控件和文本控件 // 加载传入的布局 // false： 只让我们在父布局中声明的layout属性升序，但是部位这个view添加父布局 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView)view.findViewById(R.id.fruit_name); // 缓存图片控件和文本控件的实例 view.setTag(viewHolder); &#125; else&#123; view = convertView; // 取出缓存 viewHolder = (ViewHolder)view.getTag(); // 重新获取ViewHolder &#125; // 直接使用缓存中的图片控件和文本控件的实例 // 图片控件设置图片资源 viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; class ViewHolder&#123; // 这个类是为了避免每次载入lostview都需要findviewid的苦难 ImageView fruitImage; TextView fruitName; &#125;&#125; 1.5. 活动中应用自定义适配器123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ListViewActivity extends AppCompatActivity &#123; ListView lv01; ArrayList&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_list_view); initFruits(); FruitAdapter adapter = new FruitAdapter(ListViewActivity.this, R.layout.fruit_items, fruitList); lv01 = (ListView)findViewById(R.id.list_view); lv01.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit("Apple", R.drawable.apple); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cheery); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango); fruitList.add(mango); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程1-Activity详解]]></title>
    <url>%2F2019%2F03%2F02%2FAndroid%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B1-Activity%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. Activity简介 activity是一种可以保护用户界面的组件，用于和用户交互 一个应用程序可以有0个或者多个活动 一个活动伴随着一个布局文件 1.1.Activity的创建创建活动主要分为两步： 手动创建activity文件以及对应的布局文件,通过setContentView(R.layout.XXX)关联 在AndroidMnifest中注册生效 123456789&lt;application&gt;&lt;activity android: name = ".FirstActivity" android: label = "This is first Activity"&gt; &lt;intent-filter&gt; &lt;action android:name = "...MAIN"&gt; &lt;category android:name="...LAUNCHER"&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;/application&gt; 1.2.Activity中使用ToastToast是Android系统提供的一种非常好的提醒方法，通过一些短小的信息通知用户相关信息,创建Toast需要三个参数。第一个参数是Toaset要求的上下文，第二个是Toast显示的文本内容，第三个参数是它显示的时长 1Toast.makeText(FirstActivity.this, &quot;You are Ok!!!&quot;, Toast.LENGTH_SHORT).show() 1.3.Activity中使用Menu在Android中创建下拉菜单的几个步骤如下： 在res目录下新建menu文件夹，新建menu.xml文件 在文件中添加如下代码来创建下拉菜单 123456&lt;item android:id = "@+id/add_item" andrid:title:="Add"/&gt;&lt;item android:id = "@+id/remove_item" andrid:title:="Remove"/&gt; 主活动中重写onCreateOptionMenu()方法（通过Ctrl+O） 12345678public boolean onCreateOptionMenu(Menu menu)&#123; // 通过getMenuInfalter()方法得到MenuInfalter对象，调用inflate()方法来创建菜单 // 参数1： 指定那个资源文件来创建菜单 // 参数2： 指定我们的额菜单项将添加到那个menu对象中 getMenuInflater().inflate(R.meanu.main,menu); // 允许创建的菜单显示出来 return true;&#125; 为menu绑定监听器,重写onOptionsItemSelected()方法 123456789101112public boolean onOptionsItemSelected(MenuItem item)&#123; switch (item.getItemId())&#123; case R.id.add_item: Toast.makeText(this, "you clicked add", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, "you clicked remove", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125; 1.4. 使用Intent在活动之间穿梭Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还不可以在不同组件之间传递数据，Intent有两种形式显示Intent和隐示Intent,首先看显示Intent 显示Intent切换activity1Intent(Context packageContext, Class&lt;?&gt;cls) 从一个Activity跳到另外一个Activity的代码是 12Intent intent = new Intent(FirstActivity.this, SecondActivtiy.class);startActivity(intent); 隐示Intent切换activity隐示Intent不明确指明需要启动哪个活动，而知指定一系列更为抽象的action和category信息，然后交给系统去分析这个intent并找到合适的活动去启动(可以响应这个隐示Intent的活动) 在secondactivity的声明文件中写 123456&lt;activity android: name = ".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name = "...ACTION_START"&gt; &lt;category android:name="...category.DEFAULT"&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 上面的代码中指明了当前活动可以响应com.example.activitytest.ACTION_START这个action，而标签包含了一些附加信息，更加明确的指明了当前的活动能够响应的Intent中还可能带有的catogory，只有和中的内容同事匹配上Intent中指定的action和category时，才能够响应这个活动 修改FirstActiivty的代码为如下： 123Intent intent = new Intent("com.example.activitytest.ACTION_START");intent.addCategory("com.example.activitytest.DEFAULT")startActivity(intent) 这个方法一样可以切换activity 1.5. 通过Intent向下一个活动传递数据传数据 123456public void onClick(View v)&#123; String data = "hello from FirstActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intent.putExtra("extra_data", data); startActivity(intent);&#125; 取数据 123Intent intent = getIntent();String data = intent.getStringExtra("extra_data");Log.d("SecondActivity",data); 1.6. 返回数据给上一个活动 通过调用startActivtiyForResult()方法也是用于启动活动，但是这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 接收两个参数，第一个参数是Intent，第二个参数是请求吗，用于在之后的回调中判断数据的来源 传入数据 12345public void onClick(View v)&#123; String data = "hello from FirstActivity"; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivtiyForResult(intent, 1)&#125; 然后在第二个activity中添加返回数据的逻辑 1234Intent intent = new Intent();intent.putExtra("data_return", "hello first activity");setResult(RESULT_OK,intent);finish(); // 销毁的时候回回调上一个活动的onActivityResult()方法，因此我们需要重写那个方法来获得数据 1234567891011// 在firstActivity的onActivityResult()switch (requestCode)&#123; case 1: if (resultCode == RESULT_OK)&#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActviity", returnedData); &#125; break; default:&#125; 2. 活动的生命周期 2.1. 活动的状态 运行状态： 当活动处在返回栈的栈顶时 暂停状态： 当活动不再栈顶时，但仍然可见(屏幕对话框模式) 停止状态： 当活动不在栈顶，且完全不可见 销毁状态： 被内存回收 2.1. 活动的生存周期 周期 状态 说明 建议操作 onCreate() Created 第一次创建时调用，且只执行一次 活动的初始化操作，加载布局，绑定事件 onStart() Started 活动由不可见变为可见，完成得很快 app和用户交互，初始化组件 onResume() 运行状态 准备和用户交互时调用 当有异常时，进入暂停状态 onPause() 暂停状态 系统准备去启动或者恢复一个活动时调用 停止一些不想运行的操作(关闭camera),释放系统资源 onStop() 停止状态 活动完全不可见时调用 释放heavy任务，关闭CPU中的任务，保存到数据库 onDestroy() 销毁状态 活动销毁前调用 onRestart() 由停止状态变为运行状态 2.2. 保存活动的运行状态 通过onSaveInstanceState()方法保证在活动被回收之前一定会被调用，通过这个方法来解决活动被回收时临时数据得不到保存的问题 此方法会携带一个Bundle类型的参数，这个参数提供了一系列犯法来保存数据，putString(key,value),putInt(key,value) 保存数据 123456@overrideprotected void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); String tempData = "Something you just typed"; outState.putString("data_key", tempData)&#125; 恢复数据 ：在OnCreate()方法中取值就可以了 123456789@overrideprotected void onCreate(Bundle savedInstanceState)&#123; ....; if (savedInstanceState !=null)&#123; String tempData = savedInstanceState.getString("data_key"); Log.d(TAG, tempData); &#125;&#125; 3. 关于Activity的一些其他技巧3.1. 如何在任意activity中直接退出？如果目前你手机界面还在第三个activity中，你会发现当前退出程序很麻烦，需连续按3此Back键才行，按Home键至少把程序挂起，并没有退出程序 设置一个专门的集合类对所有的活动管理就行了 12345678910111213141516171819public class ActivityyCollector&#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity)&#123; activities.add(activity); &#125; public static void removeActivity(Activity activity)&#123; activities.remove(activity); &#125; public static void finishALL()&#123; for (Activity activity : activities)&#123; if (!activity.isFinishing())&#123; activity.finish(); &#125; &#125; &#125;&#125; 然后在活动中可用直接通过这个类来动态管理活动 123456789101112131415public class BaseActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); Log.d("BaseActivity",getClass().getSimpleName()); ActivityyCollector.addActivity(this); &#125; @Override protected void onDestroy()&#123; super.onDestroy(); ActivityyCollector.removeActivity(this); &#125; &#125;]]></content>
      <categories>
        <category>Android Development</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
